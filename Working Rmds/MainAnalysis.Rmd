---
title: "<i>invivoPKfit</i> and <i>CvTdb</i> figures"
author: "Christopher Cook, John Wambaugh, Caroline Ring"
date: "11/15/2022"
output:
  html_document: default
  word_document: default
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(results = TRUE)
knitr::opts_chunk$set(message = FALSE)
```

```{r, include = FALSE}
library(tidyverse)
library(data.table)
library(readxl)
devtools::load_all("../invivopkfit")
```

Read in CvTdb data.

```{r, load_cvt, eval = TRUE}
cvt_data <- fread("../inst/ext/cvt_data_2022_12_15_16_20_21.csv")
```

```{r}
cvt <- preprocess_data(data.set = cvt_data,
                       names_list =list(
                       "Compound_Dosed" = "studies.test_substance_name_original",
                              "DTXSID_Dosed" = "chemicals_dosed.dsstox_substance_id",
                              "CAS_Dosed" = "chemicals_dosed.dsstox_casrn",
                              "Compound_Analyzed" = "series.analyte_name_original",
                              "DTXSID_Analyzed" = "chemicals_analyzed.dsstox_substance_id",
                              "CAS_Analyzed" = "chemicals_analyzed.dsstox_casrn",
                      "Reference" = "documents_reference.id",
                      "Extraction" = "documents_extraction.id",
                      "Species" = "subjects.species",
                      "Weight" ="subjects.weight_kg",
                      "Weight.Units" = NULL,
                      "Dose" = "correct.dose_level_normalized",
                      "Dose.Units" = NULL,
                      "Time" = "conc_time_values.time_hr",
                      "Time.Units" = NULL,
                      "Media" = "series.conc_medium_normalized",
                      "Value" = "conc_time_values.conc",
                      "Value.Units" = NULL,
                      "Route" = "studies.administration_route_normalized",
                      "LOQ" = "series.loq_normalized",
                      "Subject" = "subjects.id",
                              "N_Subjects" = "series.n_subjects_in_series",
                              "Value_SD" = "conc_time_values.conc_sd"),
                    defaults_list =   list(
                      "Weight.Units" = "kg",
                      "Dose.Units" = "mg/kg",
                      "Time.Units" = "h",
                      "Value.Units" = "mg/L"),
      ratio_conc_to_dose = 1,
                    calc_loq_factor = 0.45,
                    routes_keep = c("po", "iv"),
                    media_keep = c("blood", "plasma"),
      suppress.messages = FALSE)
```

There are many, many cases where N > 1 but no SD is reported. Can we impute these based on patterns in the cases where SD is reported? Calculate mean and SD for the individual cases:

```{r}
cvt <- as.data.table(cvt)
cvt_summarized <- cvt[N_Subjects==1,
                      .(meanval = mean(Value, na.rm = TRUE),
                        sdvals = sd(Value, na.rm = TRUE),
                        n = .N),
                      by = .(Reference, DTXSID, Media, Dose)]
ggplot(cvt_summarized) +
  geom_point(aes(x = meanval, y = sdvals, color = n)) +
  scale_x_log10() + scale_y_log10() + scale_color_viridis_c(trans = "log10")

summary(lm(log10(sdvals) ~ log10(meanval), data = cvt_summarized))
```

The relationship between sample SD and sample mean seems to be almost the identity line.

What about the multi-subject cases with reported SD?

```{r}
ggplot(cvt[N_Subjects > 1],
       aes(x = Value, y = Value_SD)) +
  geom_point(aes(x = Value, y = Value_SD, color = N_Subjects))  +
  scale_x_log10() + scale_y_log10() + geom_smooth(method = "lm")

summary(lm(log10(Value_SD) ~ log10(Value), data = cvt[N_Subjects > 1]))
```

This one isn't quite the identity line but still, we can get some idea.

These ones with entirely missing SDs are different from the studies where only a few SDs are missing. When only a few are missing, it was usually because the data were pulled from a plot where the error bars were smaller thant the plotting symbol on a few points. Instead of recording the size of the symbol as the error bars, the error was recorded as NA. But when all SDs are missing, it is usually because the study did not report the SDs in the first place. 

In this case, it seems like a reasonable choice to impute the mean value itself as the SD. This relation seems to be borne out by the individual-anumal data, and it is more conservative than the relation suggested by the (limited) multi-animal data. I will make that change.

Run a one-compartment fit on the data, and write out the results. Timestamp the file name with the current date and time in format YYYY_MM_DD_hh_mm.

```{r}
timestamp <- format(Sys.time(), "%Y_%m_%d_%H_%M")
```


Fit the 1-compartment model.

```{r, run_invivoPKfit_1comp}

### do 1-Compartment fit
system.time(
    PK.fit.table.1comp <- fit_all(
      data.set = cvt_data,
      model = "1compartment",
      modelfun = "analytic",
      names_list =list(
                      "Compound_Dosed" = "studies.test_substance_name_original",
                      "DTXSID_Dosed" = "chemicals_dosed.dsstox_substance_id",
                      "CAS_Dosed" = "chemicals_dosed.dsstox_casrn",
                      "Compound_Analyzed" = "series.analyte_name_original",
                      "DTXSID_Analyzed" = "chemicals_analyzed.dsstox_substance_id",
                      "CAS_Analyzed" = "chemicals_analyzed.dsstox_casrn",
                      "Reference" = "documents_reference.id",
                      "Extraction" = "documents_extraction.id",
                      "Species" = "subjects.species",
                      "Weight" ="subjects.weight_kg",
                      "Weight.Units" = NULL,
                      "Dose" = "studies.dose_level_normalized",
                      "Dose.Units" = NULL,
                      "Time" = "conc_time_values.time_hr",
                      "Time.Units" = NULL,
                      "Media" = "series.conc_medium_normalized",
                      "Value" = "conc_time_values.conc",
                      "Value.Units" = NULL,
                      "Route" = "studies.administration_route_normalized",
                      "LOQ" = "series.loq",
                      "Subject" = "subjects.id",
                      "N_Subjects" = "series.n_subjects_in_series",
                      "Value_SD" = "conc_time_values.conc_sd"),
                    defaults_list =   list(
                      "Weight.Units" = "kg",
                      "Dose.Units" = "mg/kg",
                      "Time.Units" = "h",
                      "Value.Units" = "mg/L"),
      ratio_conc_to_dose = 1,
                    calc_loq_factor = 0.45,
                    routes_keep = c("po", "iv"),
                    media_keep = c("blood", "plasma"),
      optimx_args = list(
                      "method" = "bobyqa",
                      "itnmax" = 1e6,
                      "control" = list("maximize" = TRUE,
                                       "kkt" = FALSE)
                    ),
      suppress.messages = TRUE
  )
)


write.csv(PK.fit.table.1comp,
          paste("inst/ext/PK_fit_table_1comp_",
                                    timestamp,
                                    ".csv",
                                    sep=""),
          row.names = FALSE)

post_1comp <- postprocess_data(PK_fit = PK.fit.table.1comp,
                               model = "1compartment")

write.csv(post_1comp,
          paste("inst/ext/PK_fit_postprocess_1comp_",
                                    timestamp,
                                    ".csv",
                                    sep=""),
          row.names = FALSE)

```

Fit the 2-compartment model.

```{r, run_invivoPKfit_2comp}


### do 2-Compartment fit
system.time(
    PK.fit.table.2comp <- fit_all(
      data.set = cvt_data,
      model = "flat",
      modelfun = "analytic",
      names_list =list(
                      "Compound_Dosed" = "studies.test_substance_name_original",
                      "DTXSID_Dosed" = "chemicals_dosed.dsstox_substance_id",
                      "CAS_Dosed" = "chemicals_dosed.dsstox_casrn",
                      "Compound_Analyzed" = "series.analyte_name_original",
                      "DTXSID_Analyzed" = "chemicals_analyzed.dsstox_substance_id",
                      "CAS_Analyzed" = "chemicals_analyzed.dsstox_casrn",
                      "Reference" = "documents_reference.id",
                      "Extraction" = "documents_extraction.id",
                      "Species" = "subjects.species",
                      "Weight" ="subjects.weight_kg",
                      "Weight.Units" = NULL,
                      "Dose" = "studies.dose_level_normalized",
                      "Dose.Units" = NULL,
                      "Time" = "conc_time_values.time_hr",
                      "Time.Units" = NULL,
                      "Media" = "series.conc_medium_normalized",
                      "Value" = "conc_time_values.conc",
                      "Value.Units" = NULL,
                      "Route" = "studies.administration_route_normalized",
                      "LOQ" = "series.loq",
                      "Subject" = "subjects.id",
                      "N_Subjects" = "series.n_subjects_in_series",
                      "Value_SD" = "conc_time_values.conc_sd"),
                    defaults_list =   list(
                      "Weight.Units" = "kg",
                      "Dose.Units" = "mg/kg",
                      "Time.Units" = "h",
                      "Value.Units" = "mg/L"),
      ratio_conc_to_dose = 1,
                    calc_loq_factor = 0.45,
                    routes_keep = c("po", "iv"),
                    media_keep = c("blood", "plasma"),
      optimx_args = list(
                      "method" = "bobyqa",
                      "itnmax" = 1e6,
                      "control" = list("maximize" = TRUE,
                                       "kkt" = FALSE)
                    ),
      suppress.messages = TRUE
    )
)

write.csv(PK.fit.table.2comp, paste("inst/ext/PK_fit_table_2comp_",
                                    timestamp,
                                    ".csv",
                                    sep=""), row.names = FALSE)
post_2comp <- postprocess_data(PK_fit = PK.fit.table.2comp,
                               model = "2compartment")

write.csv(post_2comp,
          paste("inst/ext/PK_fit_postprocess_2comp_",
                                    timestamp,
                                    ".csv",
                                    sep=""),
          row.names = FALSE)
```

Fit the flat model.

```{r, run_invivoPKfit_flat}

system.time(
    PK.fit.table.flat <- fit_all(
     data.set = cvt_data,
      model = "flat",
      modelfun = "analytic",
      names_list =list(
                      "Compound_Dosed" = "studies.test_substance_name_original",
                      "DTXSID_Dosed" = "chemicals_dosed.dsstox_substance_id",
                      "CAS_Dosed" = "chemicals_dosed.dsstox_casrn",
                      "Compound_Analyzed" = "series.analyte_name_original",
                      "DTXSID_Analyzed" = "chemicals_analyzed.dsstox_substance_id",
                      "CAS_Analyzed" = "chemicals_analyzed.dsstox_casrn",
                      "Reference" = "documents_reference.id",
                      "Extraction" = "documents_extraction.id",
                      "Species" = "subjects.species",
                      "Weight" ="subjects.weight_kg",
                      "Weight.Units" = NULL,
                      "Dose" = "studies.dose_level_normalized",
                      "Dose.Units" = NULL,
                      "Time" = "conc_time_values.time_hr",
                      "Time.Units" = NULL,
                      "Media" = "series.conc_medium_normalized",
                      "Value" = "conc_time_values.conc",
                      "Value.Units" = NULL,
                      "Route" = "studies.administration_route_normalized",
                      "LOQ" = "series.loq",
                      "Subject" = "subjects.id",
                      "N_Subjects" = "series.n_subjects_in_series",
                      "Value_SD" = "conc_time_values.conc_sd"),
                    defaults_list =   list(
                      "Weight.Units" = "kg",
                      "Dose.Units" = "mg/kg",
                      "Time.Units" = "h",
                      "Value.Units" = "mg/L"),
      ratio_conc_to_dose = 1,
                    calc_loq_factor = 0.45,
                    routes_keep = c("po", "iv"),
                    media_keep = c("blood", "plasma"),
      optimx_args = list(
                      "method" = "bobyqa",
                      "itnmax" = 1e6,
                      "control" = list("maximize" = TRUE,
                                       "kkt" = FALSE)
                    ),
      suppress.messages = TRUE
    )
)

write.csv(PK.fit.table.flat, paste("inst/ext/PK_fit_table_flat_",
                                    timestamp,
                                    ".csv",
                                    sep=""), row.names = FALSE)
```

For ease of plotting, get the pre-processed, harmonized data:




```{r, read_data}
### this block reads the exported model fit csv files from run_invivoPKfit

PK.fit.table.1comp <- fread(paste0("inst/ext/", "PK_fit_table_1comp_2022_12_08_09_44_34.csv",sep=""))
PK.fit.table.2comp <- fread(paste0("inst/ext/", "PK_fit_table_2comp_2022_12_08_10_31_09.csv",sep=""))
PK.fit.table.flat <- fread(paste0("inst/ext/", "PK_fit_table_flat_2022_12_08_12_03_24.csv",sep=""))

#pk_lombardo <- read_xlsx("inst/ext/Supplemental_82966_revised_corrected.xlsx")
```

Rowbind together all of the fitted parameter tables into one big one.
```{r}
pk_fit <- rbindlist(list("1comp" = PK.fit.table.1comp,
                         "2comp" = PK.fit.table.2comp,
                         "flat" = PK.fit.table.flat),
                    use.names = TRUE,
                    fill = TRUE)
```


Get a table of the winning model for each dataset (minimum AIC).

```{r}
tmp <- unique(pk_fit[, .(DTXSID, Species, Analysis_Type, model, AIC)])
setorder(tmp, DTXSID, Species, Analysis_Type, AIC, na.last = TRUE)
model_win <- tmp[, .(winmodel = model[1]), by = .(DTXSID, Species, Analysis_Type)]
pk_fit <- model_win[pk_fit, on = c("DTXSID", "Species", "Analysis_Type")]
pk_fit[, winning:=(model == winmodel)]

```

Plot concentration vs time with the best-fit params by data subset (DTXSID and species). 

Indicate the following:

- One line for each model
- Which is the winning model
- Dose group
- Blood vs. plasma
- Below LOQ vs. above LOQ (plot below-LOQ points at LOQ)
- IV vs. oral administration


Would also like to plot uncertainty in predictions based on uncertainty in parameter estimates.

Plot versions:
- Winning model only
- One model at a time
- All three models on same plot

Get unique combinations of DTXSID and species -- each of these will be one plot.

```{r}
plot_table <- unique(pk_fit[, .(DTXSID, Species)])
```

Plot all models for the joint analysis.
```{r}

#plot all models
tmp <- mapply(plot_fit,
              DTXSID_in = plot_table$DTXSID,
                     Species_in = plot_table$Species,
              MoreArgs = list(
                     model_in = "all",
                     Analysis_Type_in = "Joint",
                     DF = DF,
                     pk_fit = pk_fit,
                     n = 101,
                     log10_scale_time = FALSE,
                     file_path = "inst/ext/plots/Joint Analysis/model_all/")
                     )

```

Plot only the winning model

```{r}
#plot all models
tmp <- mapply(plot_fit,
              DTXSID_in = plot_table$DTXSID,
                     Species_in = plot_table$Species,
              MoreArgs = list(
                Analysis_Type_in = c("Joint", "Separate"),
                     model_in = "winning",
                     fitdata = DF,
                     pk_fit = pk_fit,
                     file_path = "inst/ext/plots/analysis_all_model_winning/",
                log10_scale_time = TRUE)
                     )
```




```{r, merge_pkfits, eval=FALSE}
all.fit.table <- merge_model_fits(list("1compartment"=pk_output_1comp,
                                       "2compartment"=pk_output_2comp,
                                       "flat"=pk_output_flat))
write.csv(all.fit.table, paste("inst/ext/all.fit.table.",THIS.DATE,".csv",sep=""), row.names = FALSE)
```

```{r, make_rdata, eval = FALSE}

### this block takes the csv files in read_data
# and saves them as Rdata files

### save data
paste("inst/ext/PK.fit.table.1comp.",THIS.DATE,".RData",sep="")
save(pk_output_1comp, file = paste("figures_rdata/pk_output_1comp_",THIS.DATE,".RData",sep=""))
save(pk_output_2comp, file = paste("figures_rdata/pk_output_2comp_",THIS.DATE,".RData",sep=""))
save(pk_output_flat, file = paste("figures_rdata/pk_output_flat_",THIS.DATE,".RData",sep=""))
save(raw_1comp, file = paste("figures_rdata/raw_1comp_",THIS.DATE,".RData",sep=""))
save(raw_2comp, file = paste("figures_rdata/raw_2comp_",THIS.DATE,".RData",sep=""))
save(raw_flat, file = paste("figures_rdata/raw_flat_",THIS.DATE,".RData",sep=""))
save(all.fit.table, file = paste("figures_rdata/all_fit_table_",THIS.DATE,".RData",sep=""))
save(pk_lombardo, file = paste("figures_rdata/pk_lombardo",THIS.DATE,".RData",sep=""))
```

```{r, make_invivoPKfit_plots, eval = TRUE}

### this block produces the pdf files of the model fits
# plotted on top of the original data

### 1 compartment

# pk_output_1comp_03012022 <- pk_output_1comp_03012022 %>%
#   filter(Compound == "tamoxifen") %>%
#   filter(Data.Analyzed != "Joint Analysis")

# raw_1comp_03012022 <- raw_1comp_03012022 %>%
#   filter(Compound == "tamoxifen")

junk <- plot_conctime(PK.fit.table = as.data.table(pk_output_1comp),
                      data.set = as.data.table(raw_1comp),
                      model = "1compartment")

### 2 compartment
junk <- plot_conctime(PK.fit.table = as.data.table(pk_output_2comp),
                      data.set = as.data.table(raw_2comp),
                      model = "2compartment")

junk <- plot_conctime(PK.fit.table = as.data.table(pk_output_flat),
                      data.set = as.data.table(raw_flat),
                      model = "flat")

```

```{r, make_cp_rdata, eval = FALSE}

### this block creates a data.frame of predicted concentrations
# using the estimated parameters and the observed conc-time points

######################

###########
### this is 1-compartment data
###########

###################
###################

### subset to only actual model outputs and discard "Joint Analysis" rows
pk_data1 <- pk_output_1comp %>%
  filter(param.value.type == "Fitted geometric mean" & Data.Analyzed != "Joint Analysis") %>% 
  filter(Species != "hamster")

raw_data1 <- dplyr::select(raw_1comp, -c("kelim", 
                                                  "Vdist", 
                                                  "Fgutabs", 
                                                  "kgutabs")) %>% 
  filter(Species != "hamster")

###################
###################

raw_data1$Reference <- as.character(raw_data1$Reference)

full_data_1 <- left_join(raw_data1, pk_data1, by = c("Compound", "CAS", "Reference"))
full_data_1 <- full_data_1 %>% filter(AIC != Inf)



### function that finds cp
find_cp_1 <- function(full_data_1) {plyr::adply(full_data_1, 1, mutate, cp = cp_1comp(time = Time,
                                                                                      params = full_data_1[1, ],
                                                                                      dose = Dose,
                                                                                      iv.dose = iv))}



### have to split data frame into ones with unique parameter values because cp_1comp takes constants
split_df_1 <- split(full_data_1, list(full_data_1$Compound,
                                      full_data_1$Reference,
                                      full_data_1$CAS,
                                      full_data_1$Species.x),
                    drop = TRUE)

cp_df_1 <- lapply(split_df_1, find_cp_1)

cp_df_1 <- do.call(rbind, cp_df_1)

### nomralize cp by Value
cp_df_1$cp_norm <- cp_df_1$cp / cp_df_1$Value
cp_df_1$type <- "1-Compartment"

###########
### this is 2-compartment data
###########

#######################
#######################

### subset to only actual model outputs and discard "Joint Analysis" rows
pk_data2 <- pk_output_2comp %>%
  filter(param.value.type == "Fitted geometric mean" & Data.Analyzed != "Joint Analysis")

raw_data2 <- dplyr::select(raw_2comp, -c("kelim", 
                                                  "Vdist", 
                                                  "Fgutabs", 
                                                  "kgutabs",
                                                  "V1",
                                                  "Ralphatokelim",
                                                  "Fbetaofalpha"))

########################
########################

raw_data2$Reference <- as.character(raw_data2$Reference)

full_data_2 <- left_join(raw_data2, pk_data2, by = c("Compound", "CAS", "Reference"))
full_data_2 <- full_data_2 %>% filter(AIC != Inf)
split_df_2 <- split(full_data_2, list(full_data_2$Compound,
                                      full_data_2$Reference,
                                      full_data_2$CAS,
                                      full_data_2$Species.x),
                    drop = TRUE)

### function that finds cp
find_cp_2 <- function(full_data_2) {plyr::adply(full_data_2, 1, mutate, cp = cp_2comp(time = Time,
                                                                                      params = full_data_2[1, ],
                                                                                      dose = Dose,
                                                                                      iv.dose = iv))}
cp_df_2 <- lapply(split_df_2, find_cp_2)

cp_df_2 <- do.call(rbind, cp_df_2)

cp_df_2$cp_norm <- cp_df_2$cp / cp_df_2$Value
cp_df_2$type <- "2-Compartment"

# cp_df_2 <- cp_df_2 %>%
#   filter(cp != 1e-20)

###########
### this is flat data
###########

pk_data_flat <- pk_output_flat %>%
  filter(param.value.type == "Fitted geometric mean" & Data.Analyzed != "Joint Analysis") %>% 
  filter(Species != "hamster")

raw_data_flat <- dplyr::select(raw_flat, -c("A")) %>% 
  filter(Species != "hamster")

raw_data_flat$Reference <- as.character(raw_data_flat$Reference)

full_data_flat <- left_join(raw_data_flat, pk_data_flat, by = c("Compound", "CAS", "Reference"))
full_data_flat <- full_data_flat %>% filter(AIC != Inf)
split_df_flat <- split(full_data_flat, list(full_data_flat$Compound,
                                            full_data_flat$Reference,
                                            full_data_flat$CAS,
                                            full_data_flat$Species.x),
                       drop = TRUE)

### function that finds cp
find_cp_flat <- function(full_data_flat) {plyr::adply(full_data_flat, 1, mutate, cp = cp_flat(time = Time,
                                                                                              params = full_data_flat[1, ],
                                                                                              dose = Dose,
                                                                                              iv.dose = iv))}
cp_df_flat <- lapply(split_df_flat, find_cp_flat)

cp_df_flat <- do.call(rbind, cp_df_flat)

cp_df_flat$cp_norm <- cp_df_flat$cp / cp_df_flat$Value
cp_df_flat$type <- "Flat"

#######################
#######################

### make all data.frames have the same column names so they are rbind-able
cp_df_1 <- cp_df_1[, intersect(colnames(cp_df_2), colnames(cp_df_1))]
cp_df_2 <- cp_df_2[, intersect(colnames(cp_df_1), colnames(cp_df_2))]

cp_df <- rbind(cp_df_1, cp_df_2)

cp_df <- cp_df[, intersect(colnames(cp_df_flat), colnames(cp_df))]
cp_df_flat <- cp_df_flat[, intersect(colnames(cp_df), colnames(cp_df))]

cp_df <- rbind(cp_df, cp_df_flat)

cp_df$cp_pred_error <- (cp_df$cp - cp_df$Value) / cp_df$Value

cp_df <- cp_df %>% group_by(Species.x, 
                           Compound,
                           CAS,
                           type) %>%
 mutate(cp_pred_error_range = max(cp_pred_error, na.rm = TRUE) - min(cp_pred_error, na.rm = TRUE))

### here is where you save the Rdata file
save(cp_df, file = paste("figures_rdata/cp_df_",THIS.DATE,".RData",sep=""))
```


```{r, make_cvt_variability_rdata, eval = FALSE}

### this block creates a data.frame that shows the 
# spread of CvT data via across replicate timepoints 
# for a single experiment
# if the data isn't within 2-fold of itself
# is it reasonable to say that a model should fit within 2-fold?

##################
##################

### all the raw data for each model SHOULD be the same
# so only need to use one
data <- as.data.table(raw_1comp)

##################
##################

### function that finds mean conc of each replicate timepoint
find_mean_conc <- function(data) {
  
  ### only use data with replicate timepoints
  data <- data[ ave(1:nrow(data), data$Time, FUN = length) > 1 , ]
  
  if(nrow(data) == 0) {
    return(NULL)
  } else {
    
    time_split <- split(data, data$Time)
    
    ### discard replicate timepoints where all concentrations are NA
    time_split_list <- purrr::discard(time_split, ~all(is.na(.$Value)))
    
    if(length(time_split_list) == 0) {
      return(NULL)
    } else {
      
      data <- do.call(rbind, time_split_list)
      
      ### where some replicate concentration data are NA, set them equal to the LOQ
      data$Value[is.na(data$Value)] <- data$LOQ[is.na(data$Value)]
      
      ### take the average Value for each set of timepoints
      data <- data %>%
        group_by(Time) %>%
        do(mutate(., mean_conc = mean(.$Value, na.rm = TRUE)))
      
      data <- data %>%
        group_by(Time) %>%
        do(mutate(., range_conc = max(.$Value) - min(.$Value)))
      
      ### create normalized conc values by dividing conc by mean_conc
      data$conc_norm <- data$Value/data$mean_conc
      
      data <- data[order(data$Time), ]
      
      return(data)
    }
  }
}

### this for loop applies the function 
# at data subsets of compound, data, dose, route, media
data.list <- list()
for(this.compound in unique(data[, Compound])) {
  this.compound.data <- data[Compound == this.compound]
  
  ### list of columns by which to split data.set
  col_list <- list(this.compound.data$Reference,
                   this.compound.data$Dose,
                   this.compound.data$Route,
                   this.compound.data$Media)
  
  ### split data.set into list of data.tables
  split_list <- split(this.compound.data, col_list)
  
  ### remove data.tables with 0 rows
  split_list <- keep(split_list, ~nrow(.) > 0)
  
  ### use find_mean_conc fn
  mean_conc <- lapply(split_list, find_mean_conc)
  
  test <- do.call(rbind, mean_conc)
  
  data.list[[this.compound]] <- test
}

### combine data.tables back into one large data.set
cvt_variability_df <- do.call(rbind, data.list)

### SAVE the data
save(cvt_variability_df, file = paste("figures_rdata/cvt_variability_df_",THIS.DATE,".RData",sep=""))
```

```{r, load_data}

### this block loads the Rdata files,
# as well as some other files written in below code blocks
# this saves time from having to run those below code blocks every time
# these additional files include 'cp_df' and 'cvt_variability'

### load all of this wonderful data
load(paste("figures_rdata/pk_output_1comp_",THIS.DATE,".RData",sep=""))
load(paste("figures_rdata/pk_output_2comp_",THIS.DATE,".RData",sep=""))
load(paste("figures_rdata/pk_output_flat_",THIS.DATE,".RData",sep=""))
load(paste("figures_rdata/raw_1comp_",THIS.DATE,".RData",sep=""))
load(paste("figures_rdata/raw_2comp_",THIS.DATE,".RData",sep=""))
load(paste("figures_rdata/raw_flat_",THIS.DATE,".RData",sep=""))
load(paste("figures_rdata/cp_df_",THIS.DATE,".RData",sep=""))
load(paste("figures_rdata/cvt_variability_df_",THIS.DATE,".RData",sep=""))

load(paste("figures_rdata/cp_df_",THIS.DATE,".RData",sep=""))

load("figures_rdata/pk_lombardo_02072022.Rdata")
```

```{r, make_cp_histogram}

### this block makes a histogram of the data output
# from make_cp_rdata
# there's a separate facet for each model type
# only data that were best fitted by that model
# are shown in that facet

##################
##################

pk_data <- cp_df

# cvt_data <- cvt_variability_df_04282022

##################
##################

row.names(pk_data) <- c()
full_data <- pk_data

# cvt_data <- dplyr::select(cvt_data, -c("kelim",
#                                        "Vdist",
#                                        "Fgutabs",
#                                        "kgutabs"))
# 
# ### split pk_data by model so you can properly join with raw data
# model_split <- split(pk_data, pk_data$model)
# 
# cvt_data$Reference <- as.character(cvt_data$Reference)
# 
# cvt_data$type <- "1-Compartment"
# full_data_1 <- left_join(cvt_data, model_split$`1compartment`)
# 
# cvt_data$type <- "2-Compartment"
# full_data_2 <- left_join(cvt_data, model_split$`2compartment`)
# 
# cvt_data$type <- "Flat"
# full_data_flat <- left_join(cvt_data, model_split$`flat`)
# 
# ### put data back together
# full_data <- rbind(full_data_1, full_data_2, full_data_flat)
# 
# full_data <- full_data %>%
#   filter(cp != 0)

full_data$AIC <- round(full_data$AIC, digits = 4)

### only take necessary columns to keep things clean
full_data <- full_data %>%
  distinct(Compound, Reference, Species.x, model, AIC, cp_norm)

### this pivots the data so we have AICs and cp_norms
# for each model row-wise
full_data <- full_data %>%
  group_by(Species.x, Compound, Reference, model) %>%
  mutate(row = row_number()) %>%
  pivot_wider(names_from = model,
              values_from = c(AIC, cp_norm)) %>%
  dplyr::select(-row)

full_data <- as.data.table(full_data)

### make model column equal a specific model based on AIC values
full_data <- full_data %>% mutate(model = case_when(AIC_1compartment < AIC_2compartment &
                                                      AIC_1compartment < AIC_flat ~ "1-Compartment",
                                                    AIC_2compartment < AIC_1compartment &
                                                      AIC_2compartment < AIC_flat ~ "2-Compartment",
                                                    AIC_flat < AIC_1compartment &
                                                      AIC_flat < AIC_2compartment ~ "Null",
                                                    
                                                    !is.na(AIC_1compartment) & is.na(AIC_2compartment) &
                                                      is.na(AIC_flat) ~ "1-Compartment",
                                                    !is.na(AIC_2compartment) & is.na(AIC_1compartment) &
                                                      is.na(AIC_flat) ~ "2-Compartment",
                                                    !is.na(AIC_flat) & is.na(AIC_1compartment) &
                                                      is.na(AIC_2compartment) ~ "Null",
                                                    
                                                    is.na(AIC_1compartment) &
                                                      AIC_flat < AIC_2compartment ~ "Null",
                                                    is.na(AIC_1compartment) &
                                                      AIC_2compartment < AIC_flat ~ "2-Compartment",
                                                    is.na(AIC_2compartment) &
                                                      AIC_flat < AIC_1compartment ~ "Null",
                                                    is.na(AIC_2compartment) &
                                                      AIC_1compartment < AIC_flat ~ "1-Compartment",
                                                    is.na(AIC_flat) &
                                                      AIC_1compartment < AIC_2compartment ~"1-Compartment",
                                                    is.na(AIC_flat) &
                                                      AIC_2compartment <AIC_1compartment ~"2-Compartment"))

### make cp_norm equal to the cp_norm that corresponds to the best fitting model
full_data <- full_data %>%
  mutate(cp_norm = case_when(model == "1-Compartment" ~ cp_norm_1compartment,
                             model == "2-Compartment" ~ cp_norm_2compartment,
                             model == "Null" ~ cp_norm_flat))

full_data[, model := paste("Model:", model)]

### this creates a new column that says how many unique sets of Compound, Reference,
# and Species correspond to each model
full_data[, chem_ref_spec_count := uniqueN(.SD), .SDcols = c("Compound", 
                                                             "Reference",
                                                             "Species.x"), 
          by = "model"]

full_data[, chem_ref_spec_count := paste("Chemical-Reference-Species:", chem_ref_spec_count)]

### make plot, facet by model and chem_ref_spec_count
p <- ggplot(data = full_data,
            mapping = aes(x = cp_norm)) +
  geom_histogram(binwidth = 0.325) +
  geom_vline(xintercept = c(0.5, 2),
             color = "Red",
             linetype = "dashed") +
  # xlim(0, 1e42) +
  # ylim(0, 400) +
  # scale_y_log10()+
  theme(title = element_text(size = 16),
        axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  # scale_x_log10() +
  scale_x_log10(limits = c(1e-3, 1e3), labels = scientific) +
  scale_y_continuous(labels = scientific) +
  theme_bw() +
  labs(x = "Predicted/Observed",
       y = "Number of Observations") +
  facet_wrap(. ~ model + chem_ref_spec_count) 

p
```

```{r, make_cp_error_histogram}

### I think this is little outdated but whatever I'm gonna keep it here
# Think is was just plotting Cpred - Cobs

##################
##################

# data <- cp_df_12212021
# data <- cp_df_03012022
data <- cp_df

##################
##################

data <- data %>%
  filter(cp != 1e-20)

data <- data %>%
  distinct(Species.x, Compound, CAS, cp_pred_error_range)

p <- ggplot(data = data,
            mapping = aes(x = cp_pred_error_range)) +
  geom_histogram() +
  scale_x_log10() +
  facet_wrap(. ~type)

p
```

```{r, make_cp_error_versus_dose}

### I think this is little outdated but whatever I'm gonna keep it here


##################
##################

data <- cp_df

##################
##################

data <- data %>%
  filter(type == "1-Compartment")

data <- data %>%
  group_by(Compound, CAS, Dose) %>%
  mutate(average = mean(cp_pred_error))

p <- ggplot(data = data, mapping = aes(x = Dose, y = average)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10()

p

```


```{r, make_cvt_variability_histogram}

### this block makes the histogram
# of cvt variability using the data.frame
# made from make_cvt_variability_rdata

#################
#################

data <- cvt_variability_df
# data <- cvt_variability_df_12212021

#################
#################

p <- ggplot(data, aes(x = conc_norm)) +
  geom_histogram(binwidth = 0.25) +
  xlim(c(-0.5, 4)) +
  geom_vline(xintercept = c(0.5, 2),
             color = "Red",
             linetype = "dashed") +
  theme_bw() +
  labs(x = "Normalized concentration",
       y = "Number of observations")
p
```

```{r, make_density_plot}

### this block makes a density plot with cvt variabity
# and normalized predicted concentrations
# it's basically a combination of the other two histograms
# expect here we limit cp observations those that have replicate timepoint
# data, so it matches the cvt variability data, thus making it 
# comparable

##################
##################

# pk_data <- cp_df_03012022
pk_data <- cp_df

cvt_data <- cvt_variability_df

##################
##################

### i hate row names
row.names(pk_data) <- c()

### making these null so I don't have to deal
# with duplicate .x and .y's
# only need the ones from pk_data
cvt_data <- dplyr::select(cvt_data, -c("kelim", 
                                       "Vdist", 
                                       "Fgutabs", 
                                       "kgutabs"))

### split pk_data by model so you can properly join with raw data
model_split <- split(pk_data, pk_data$model)

### References were of different classes for some reason
# so had to change
cvt_data$Reference <- as.character(cvt_data$Reference)

cvt_data$type <- "1-Compartment"
full_data_1 <- left_join(cvt_data, model_split$`1compartment`)

cvt_data$type <- "2-Compartment"
full_data_2 <- left_join(cvt_data, model_split$`2compartment`)

cvt_data$type <- "Flat"
full_data_flat <- left_join(cvt_data, model_split$`flat`)

### put data back together
full_data <- rbind(full_data_1, full_data_2, full_data_flat)

### not sure why there were 0s,
# but they were screwing things up
full_data <- full_data %>%
  filter(cp != 0)

full_data$AIC <- round(full_data$AIC, digits = 4)

full_data <- full_data %>%
  distinct(Compound, Reference, model, Species.x, conc_norm, AIC, cp_norm)

### 
### 
full_data <- full_data %>%
  group_by(Species.x, Compound, Reference, model) %>%
  mutate(row = row_number()) %>%
  pivot_wider(names_from = model,
              values_from = c(AIC, cp_norm)) %>%
  dplyr::select(-row)

full_data <- full_data %>% mutate(model = case_when(AIC_1compartment < AIC_2compartment & 
                                                      AIC_1compartment < AIC_flat ~ "1-Compartment",
                                                    AIC_2compartment < AIC_1compartment &
                                                      AIC_2compartment < AIC_flat ~ "2-Compartment",
                                                    AIC_flat < AIC_1compartment &
                                                      AIC_flat < AIC_2compartment ~ "Null",
                                                    
                                                    !is.na(AIC_1compartment) & is.na(AIC_2compartment) &
                                                      is.na(AIC_flat) ~ "1-Compartment",
                                                    !is.na(AIC_2compartment) & is.na(AIC_1compartment) & 
                                                      is.na(AIC_flat) ~ "2-Compartment",
                                                    !is.na(AIC_flat) & is.na(AIC_1compartment) & 
                                                      is.na(AIC_2compartment) ~ "Null",
                                                    
                                                    is.na(AIC_1compartment) &
                                                      AIC_flat < AIC_2compartment ~ "Null",
                                                    is.na(AIC_1compartment) &
                                                      AIC_2compartment < AIC_flat ~ "2-Compartment",
                                                    is.na(AIC_2compartment) &
                                                      AIC_flat < AIC_1compartment ~ "Null",
                                                    is.na(AIC_2compartment) &
                                                      AIC_1compartment < AIC_flat ~ "1-Compartment",
                                                    is.na(AIC_flat) &
                                                      AIC_1compartment < AIC_2compartment ~"1-Compartment",
                                                    is.na(AIC_flat) &
                                                      AIC_2compartment <AIC_1compartment ~"2-Compartment"))

full_data <- full_data %>%
  mutate(cp_norm = case_when(model == "1-Compartment" ~ cp_norm_1compartment,
                             model == "2-Compartment" ~ cp_norm_2compartment,
                             model == "Null" ~ cp_norm_flat))

### remove super outlier data from triclosan, for visualization purposes
full_data <- full_data %>%
  filter(cp_norm > 1e-10 & cp_norm < 1e8) # also high one for the heck of it

length(unique(full_data$Compound[full_data$model == "1-Compartment"]))
length(unique(full_data$Compound[full_data$model == "2-Compartment"]))
length(unique(full_data$Compound[full_data$model == "Null"]))

null_vec <- as.vector(unique(full_data$Compound[full_data$model == "Null"]))

full_data <- as.data.table(full_data)

full_data[, model := paste("Model:", model)]

full_data[, chem_ref_spec_count := uniqueN(.SD), .SDcols = c("Compound", 
                                                             "Reference",
                                                             "Species.x"), 
          by = "model"]

full_data[, chem_ref_spec_count := paste("Chemical-Reference-Species:", chem_ref_spec_count)]

# full_data <- full_data %>%
#   mutate(cp_norm = case_when(model == "1comparment" ~ cp_norm_1compartment,
#                              model == "2compartment" ~ cp_norm_2compartment))

# full_data$cp_norm[full_data$model == "2compartment"] <- full_data$cp_norm_2compartment
# full_data$cp_norm[full_data$model == "1compartment"] <- full_data$cp_norm_1compartment

# full_data <- full_data %>%
# mutate(across(everything(), ~ifelse(. == "", NA, as.character(.))))

# filter(Compound != "triclosan")
# filter(Compound != "tamoxifen")

###########
###########
###########

split_full_data <- split(full_data, full_data$model)

full_data_1 <- split_full_data$`Model: 1-Compartment`

### Find number of points in each plot panel for 1-compartment
full_data_1_center <- full_data_1 %>% filter(conc_norm >= 0.5 & conc_norm <= 2)
full_data_1_center <- full_data_1_center %>% filter(cp_norm >= 0.5 & cp_norm <= 2)
ratio_1_center <- nrow(full_data_1_center) / nrow(full_data_1 %>% filter(!is.na(cp_norm)))

full_data_1_green <- full_data_1 %>% filter(conc_norm < 0.5 | conc_norm > 2)
full_data_1_green <- full_data_1_green %>% filter(cp_norm < 0.5 | cp_norm > 2)
ratio_1_green <- nrow(full_data_1_green) / nrow(full_data_1 %>% filter(!is.na(cp_norm)))

full_data_1_gray <- full_data_1 %>% filter(conc_norm < 0.5 | conc_norm > 2)
full_data_1_gray <- full_data_1_gray %>% filter(cp_norm >= 0.5 & cp_norm <= 2)
ratio_1_gray <- nrow(full_data_1_gray) / nrow(full_data_1 %>% filter(!is.na(cp_norm)))

full_data_1_tan <- full_data_1 %>% filter(conc_norm >= 0.5 & conc_norm <= 2)
full_data_1_tan <- full_data_1_tan %>% filter(cp_norm < 0.5 | cp_norm > 2)
ratio_1_tan <- nrow(full_data_1_tan) / nrow(full_data_1 %>% filter(!is.na(cp_norm)))

###########
###########

full_data_2 <- split_full_data$`Model: 2-Compartment`

### Find number of points in each plot panel for 2-compartment
full_data_2_center <- full_data_2 %>% filter(conc_norm >= 0.5 & conc_norm <= 2)
full_data_2_center <- full_data_2_center %>% filter(cp_norm >= 0.5 & cp_norm <= 2)
ratio_2_center <- nrow(full_data_2_center) / nrow(full_data_2 %>% filter(!is.na(cp_norm)))

full_data_2_green <- full_data_2 %>% filter(conc_norm < 0.5 | conc_norm > 2)
full_data_2_green <- full_data_2_green %>% filter(cp_norm < 0.5 | cp_norm > 2)
ratio_2_green <- nrow(full_data_2_green) / nrow(full_data_2 %>% filter(!is.na(cp_norm)))

full_data_2_gray <- full_data_2 %>% filter(conc_norm < 0.5 | conc_norm > 2)
full_data_2_gray <- full_data_2_gray %>% filter(cp_norm >= 0.5 & cp_norm <= 2)
ratio_2_gray <- nrow(full_data_2_gray) / nrow(full_data_2 %>% filter(!is.na(cp_norm)))

full_data_2_tan <- full_data_2 %>% filter(conc_norm >= 0.5 & conc_norm <= 2)
full_data_2_tan <- full_data_2_tan %>% filter(cp_norm < 0.5 | cp_norm > 2)
ratio_2_tan <- nrow(full_data_2_tan) / nrow(full_data_2 %>% filter(!is.na(cp_norm)))

###########
###########

full_data_flat <- split_full_data$`Model: Null`

### Find number of points in each plot panel for 2-compartment
full_data_flat_center <- full_data_flat %>% filter(conc_norm >= 0.5 & conc_norm <= 2)
full_data_flat_center <- full_data_flat_center %>% filter(cp_norm >= 0.5 & cp_norm <= 2)
ratio_flat_center <- nrow(full_data_flat_center) / nrow(full_data_flat %>% filter(!is.na(cp_norm)))

full_data_flat_green <- full_data_flat %>% filter(conc_norm < 0.5 | conc_norm > 2)
full_data_flat_green <- full_data_flat_green %>% filter(cp_norm < 0.5 | cp_norm > 2)
ratio_flat_green <- nrow(full_data_flat_green) / nrow(full_data_flat %>% filter(!is.na(cp_norm)))

full_data_flat_gray <- full_data_flat %>% filter(conc_norm < 0.5 | conc_norm > 2)
full_data_flat_gray <- full_data_flat_gray %>% filter(cp_norm >= 0.5 & cp_norm <= 2)
ratio_flat_gray <- nrow(full_data_flat_gray) / nrow(full_data_flat %>% filter(!is.na(cp_norm)))

full_data_flat_tan <- full_data_flat %>% filter(conc_norm >= 0.5 & conc_norm <= 2)
full_data_flat_tan <- full_data_flat_tan %>% filter(cp_norm < 0.5 | cp_norm > 2)
ratio_flat_tan <- nrow(full_data_flat_tan) / nrow(full_data_flat %>% filter(!is.na(cp_norm)))

###########
###########
###########

# rect_df1 <- data.frame(xmin = c(0, 0, 2, 2, 0, 2, 0.5, 0.5),
#                       xmax = c(0.5, 0.5, Inf, Inf, 0.5, Inf, 2, 2),
#                       ymin = c(2, 0, 0, 2, 0.5, 0.5, 2, 0),
#                       ymax = c(Inf, 0.5, 0.5, Inf, 2, 2, Inf, 0.5),
#                       panel_key = c(paste("Poor Fit, Outlier Data", 
#                                           paste("(", round(100 * ratio_1_green, digits = 1), "%", ")", sep = ""), 
#                                           sep = " "),
#                                     paste("Poor Fit, Outlier Data", 
#                                           paste("(", round(100 * ratio_1_green, digits = 1), "%", ")", sep = ""),
#                                           sep = " "),
#                                     paste("Poor Fit, Outlier Data", 
#                                           paste("(", round(100 * ratio_1_green, digits = 1), "%", ")", sep = ""), 
#                                           sep = " "),
#                                     paste("Poor Fit, Outlier Data", 
#                                           paste("(", round(100 * ratio_1_green, digits = 1), "%", ")", sep = ""),
#                                           sep = " "),
#                                     paste("Good Fit, Outlier Data", 
#                                           paste("(", round(100 * ratio_1_tan, digits = 1), "%", ")", sep = ""), 
#                                           sep = " "),
#                                     paste("Good Fit, Outlier Data", 
#                                           paste("(", round(100 * ratio_1_tan, digits = 1), "%", ")", sep = ""), 
#                                           sep = " "),
#                                    paste("Poor Fit, Typical Data", 
#                                           paste("(", round(100 * ratio_1_gray, digits = 1), "%", ")", sep = ""), 
#                                           sep = " "),
#                                    paste("Poor Fit, Typical Data", 
#                                           paste("(", round(100 * ratio_1_gray, digits = 1), "%", ")", sep = ""), 
#                                           sep = " ")))
# 
# rect_df2 <- data.frame(xmin = c(0, 0, 2, 2, 0, 2, 0.5, 0.5),
#                       xmax = c(0.5, 0.5, Inf, Inf, 0.5, Inf, 2, 2),
#                       ymin = c(2, 0, 0, 2, 0.5, 0.5, 2, 0),
#                       ymax = c(Inf, 0.5, 0.5, Inf, 2, 2, Inf, 0.5),
#                       panel_key = c(paste("Poor Fit, Outlier Data", 
#                                           paste("(", round(100 * ratio_2_green, digits = 1), "%", ")", sep = ""), 
#                                           sep = " "),
#                                     paste("Poor Fit, Outlier Data", 
#                                           paste("(", round(100 * ratio_2_green, digits = 1), "%", ")", sep = ""),
#                                           sep = " "),
#                                     paste("Poor Fit, Outlier Data", 
#                                           paste("(", round(100 * ratio_2_green, digits = 1), "%", ")", sep = ""), 
#                                           sep = " "),
#                                     paste("Poor Fit, Outlier Data", 
#                                           paste("(", round(100 * ratio_2_green, digits = 1), "%", ")", sep = ""),
#                                           sep = " "),
#                                     paste("Good Fit, Outlier Data", 
#                                           paste("(", round(100 * ratio_2_tan, digits = 1), "%", ")", sep = ""), 
#                                           sep = " "),
#                                     paste("Good Fit, Outlier Data", 
#                                           paste("(", round(100 * ratio_2_tan, digits = 1), "%", ")", sep = ""), 
#                                           sep = " "),
#                                    paste("Poor Fit, Typical Data", 
#                                           paste("(", round(100 * ratio_2_gray, digits = 1), "%", ")", sep = ""), 
#                                           sep = " "),
#                                    paste("Poor Fit, Typical Data", 
#                                           paste("(", round(100 * ratio_2_gray, digits = 1), "%", ")", sep = ""), 
#                                           sep = " ")))
# 
# 
# rect_p1 <- ggplot() +
#   geom_rect(data = rect_df1, aes(xmin = xmin,
#                                 ymin = ymin,
#                                 xmax = xmax,
#                                 ymax = ymax,
#                                 fill = panel_key),
#             alpha = 0.3, inherit.aes = FALSE) +
#   scale_fill_manual(name = "Panel Key",
#                     values = c("#361D2E",
#                                "#86A397",
#                                "#E1B07E")) +
#   theme_bw() +
#   theme(panel.spacing = unit(2, "lines")) +
#   geom_vline(xintercept = c(0.5, 2),
#              linetype = "dashed") +
#   geom_hline(yintercept = c(0.5, 2),
#              linetype = "dashed") +
#   scale_x_log10() +
#   scale_y_log10() +
#   labs(x = "Data Variability",
#        y = "Model Error") +
#   guides(fill = guide_legend(override.aes = list(size = 0.1)))
# 
# rect_p2 <- ggplot() +
#   geom_rect(data = rect_df2, aes(xmin = xmin,
#                                 ymin = ymin,
#                                 xmax = xmax,
#                                 ymax = ymax,
#                                 fill = panel_key),
#             alpha = 0.3, inherit.aes = FALSE) +
#   scale_fill_manual(name = "Panel Key",
#                     values = c("#361D2E",
#                                "#86A397",
#                                "#E1B07E")) +
#   theme_bw() +
#   theme(panel.spacing = unit(2, "lines")) +
#   geom_vline(xintercept = c(0.5, 2),
#              linetype = "dashed") +
#   geom_hline(yintercept = c(0.5, 2),
#              linetype = "dashed") +
#   scale_x_log10() +
#   scale_y_log10() +
#   labs(x = "Data Variability",
#        y = "Model Error") +
#   guides(fill = guide_legend(override.aes = list(size = 0.1)))
# 
# ###################
# fill_legend1 <- get_legend(rect_p1)
# fill_legend2 <- get_legend(rect_p2)
# ##################

p <- ggplot(data = full_data,
            mapping = aes(x = conc_norm, y = cp_norm)) +
  annotate(geom = "rect", xmin = 0, xmax = 0.5, ymin = 2, ymax = Inf, alpha = 0.3, fill = "#86A397") +
  annotate(geom = "rect", xmin = 0, xmax = 0.5, ymin = 0, ymax = 0.5, alpha = 0.3, fill = "#86A397") +
  annotate(geom = "rect", xmin = 2, xmax = Inf, ymin = 0, ymax = 0.5, alpha = 0.3, fill = "#86A397") +
  annotate(geom = "rect", xmin = 2, xmax = Inf, ymin = 2, ymax = Inf, alpha = 0.3, fill = "#86A397") +
  annotate(geom = "rect", xmin = 0, xmax = 0.5, ymin = 0.5, ymax = 2, alpha = 0.3, fill = "#361D2E") +
  annotate(geom = "rect", xmin = 2, xmax = Inf, ymin = 0.5, ymax = 2, alpha = 0.3, fill = "#361D2E") +
  annotate(geom = "rect", xmin = 0.5, xmax = 2, ymin = 2, ymax = Inf, alpha = 0.3, fill = "#E1B07E") +
  annotate(geom = "rect", xmin = 0.5, xmax = 2, ymin = 0, ymax = 0.5, alpha = 0.3, fill = "#E1B07E") +
  annotate(geom = "rect", xmin = 0.5, xmax = 2, ymin = 0.5, ymax = 2.0, alpha = 0.5, fill = "black") +
  theme_bw() +
  theme(panel.spacing = unit(2, "lines")) +
  geom_bin2d(bins = 100) +
  scale_fill_distiller(palette = "Blues") +
  geom_vline(xintercept = c(0.5, 2),
             linetype = "dashed") +
  geom_hline(yintercept = c(0.5, 2),
             linetype = "dashed") +
  scale_x_log10(n.breaks = 4, labels = scientific) +
  scale_y_log10() +
  labs(x = "Data Variability",
       y = "Model Performance") +
  facet_wrap(. ~ model + chem_ref_spec_count) +
  theme(strip.text.x = element_text(size = 7))

p

# ##################
# 
# data_p_final <- data_p +
#   # inset_element(fill_legend1, 0.1, 1, 0.5, 1) +
#   inset_element(fill_legend2, 0.6, 0.5, 0.7, 0.2, clip = TRUE)
#  
# data_p_final
```

```{r, make_sigma_distribution_histogram}

# pk_data <- cp_df_03012022
pk_data <- cp_df

cvt_data <- cvt_variability_df

##################
##################

row.names(pk_data) <- c()

cvt_data <- dplyr::select(cvt_data, -c("kelim", 
                                       "Vdist", 
                                       "Fgutabs", 
                                       "kgutabs"))

### split pk_data by model so you can properly join with raw data
model_split <- split(pk_data, pk_data$model)

cvt_data$Reference <- as.character(cvt_data$Reference)

cvt_data$type <- "1-Compartment"
full_data_1 <- left_join(cvt_data, model_split$`1compartment`)

cvt_data$type <- "2-Compartment"
full_data_2 <- left_join(cvt_data, model_split$`2compartment`)

cvt_data$type <- "Flat"
full_data_flat <- left_join(cvt_data, model_split$`flat`)

### put data back together
full_data <- rbind(full_data_1, full_data_2, full_data_flat)

full_data <- full_data %>%
  filter(cp != 0)

# full_data$AIC <- round(full_data$AIC, digits = 4)

full_data <- full_data %>%
  pivot_wider(names_from = model,
              values_from = c(AIC, sigma_value)) %>%
  unchop(everything()) 

full_data <- full_data %>% mutate(model = case_when(AIC_1compartment < AIC_2compartment & 
                                                      AIC_1compartment < AIC_flat ~ "1-Compartment",
                                                    AIC_2compartment < AIC_1compartment &
                                                      AIC_2compartment < AIC_flat ~ "2-Compartment",
                                                    AIC_flat < AIC_1compartment &
                                                      AIC_flat < AIC_2compartment ~ "Null",
                                                    
                                                    !is.na(AIC_1compartment) & is.na(AIC_2compartment) &
                                                      is.na(AIC_flat) ~ "1-Compartment",
                                                    !is.na(AIC_2compartment) & is.na(AIC_1compartment) & 
                                                      is.na(AIC_flat) ~ "2-Compartment",
                                                    !is.na(AIC_flat) & is.na(AIC_1compartment) & 
                                                      is.na(AIC_2compartment) ~ "Null",
                                                    
                                                    is.na(AIC_1compartment) &
                                                      AIC_flat < AIC_2compartment ~ "Null",
                                                    is.na(AIC_1compartment) &
                                                      AIC_2compartment < AIC_flat ~ "2-Compartment",
                                                    is.na(AIC_2compartment) &
                                                      AIC_flat < AIC_1compartment ~ "Null",
                                                    is.na(AIC_2compartment) &
                                                      AIC_1compartment < AIC_flat ~ "1-Compartment",
                                                    is.na(AIC_flat) &
                                                      AIC_1compartment < AIC_2compartment ~"1-Compartment",
                                                    is.na(AIC_flat) &
                                                      AIC_2compartment <AIC_1compartment ~"2-Compartment"))

full_data <- full_data %>%
  mutate(AIC = case_when(model == "1-Compartment" ~ AIC_1compartment,
                         model == "2-Compartment" ~ AIC_2compartment,
                         model == "Null" ~ AIC_flat))

full_data <- full_data %>%
  mutate(sigma_value = case_when(model == "1-Compartment" ~ sigma_value_1compartment,
                                 model == "2-Compartment" ~ sigma_value_2compartment,
                                 model == "Null" ~ sigma_value_flat))

full_data <- full_data %>%
  distinct(Compound, 
           Reference, 
           Route, 
           Species,
           Media,
           model, 
           sigma_id,
           sigma_value,
           Value,
           AIC)

full_data <- as.data.table(full_data)

full_data[, sigma_norm := sigma_value / nrow(.SD), by = .(Compound, 
                                                          Reference,
                                                          model,
                                                          sigma_id,
                                                          sigma_value)]

full_data <- as.data.frame(full_data)

full_data <- full_data %>% distinct(Compound,
                                    Reference,
                                    model,
                                    AIC,
                                    sigma_id,
                                    sigma_value,
                                    sigma_norm)

full_data <- full_data %>%
  group_by(Compound, Reference, sigma_id) %>%
  slice_min(AIC)


# ##################
# ##################
# 
# data1 <- pk_output_1comp_03012022 %>%
#   filter(param.value.type == "Fitted geometric mean" & AIC != Inf & Data.Analyzed != "Joint Analysis")
# 
# data2 <- pk_output_2comp_03012022 %>%
#   filter(param.value.type == "Fitted geometric mean" & AIC != Inf & Data.Analyzed != "Joint Analysis")
# 
# ##################
# ##################
# 
# ### assign new column, with either "1-Compartment" or "2-Compartment"
# data1 <- subset(data1, select = sigma_value)
# data1$model <- "1-Compartment"
# 
# data2 <- subset(data2, select = sigma_value)
# data2$model <- "2-Compartment"
# 
# data <- rbind(data1, data2)

p <- ggplot(data = full_data,
            mapping = aes(x = sigma_norm)) +
  geom_histogram(bins = 12) +
  # geom_density() +
  # scale_y_log10()+
  scale_x_log10() +
  theme_bw() +
  labs(x = "Sigma",
       y = "Number of observations") +
  facet_wrap(.~ model)
# geom_vline(xintercept = 0.001476315)
# stat_function(fun = dlnorm, args = list(mean = mean(log(data$sigma_value)), sd = sd(log(data$sigma_value))))

p
```

```{r make_magnitude_histogram}

##################
##################

data <- raw_1comp

##################
##################

data$X <- NULL

split_df <- split(data, list(data$Compound,
                             data$Reference,
                             data$CAS,
                             data$Dose,
                             data$Species,
                             data$Route,
                             data$Media),
                  drop = TRUE)

### find number of orders of magnitude
find_mag <- function(data) {
  
  data$Value <- abs(data$Value)
  
  diff <- log10(max(data$Value, na.rm = TRUE)) - log10(min(data$Value, na.rm = TRUE))
  
  diff <- round(diff)
  
  return(diff)
  
}

data <- lapply(split_df, find_mag)


data <- pivot_longer(as.data.frame(data), cols = everything())

p <- ggplot(data = data, mapping = aes(x = value)) +
  geom_histogram(bins = 5, binwidth = 0.5) +
  xlab("Orders of magnitude") + theme_bw()

p
```

```{r make_joint_sigma_plot, eval = FALSE}

##################
##################

data1 <- as.data.table(pk_output_1comp %>%
                         filter(param.value.type == "Fitted geometric mean"))

data2 <- as.data.table(pk_output_2comp %>%
                         filter(param.value.type == "Fitted geometric mean"))

##################
##################

### find data with repeated sigma_id values
find_rep_sigma <- function(data) {
  
  data <- data[ ave(1:nrow(data), data$sigma_id, FUN=length) > 1 , ]
  
  if(nrow(data) == 0) {
    return(NULL)
  } else {
    
    return(data)
  }
}

split_list_1 <- split(data1, data1$Compound)
rep_sigma_1 <- lapply(split_list_1, find_rep_sigma)
data1 <- do.call(rbind, rep_sigma_1)
data1 <- subset(data1, select = c(param.value.type, sigma_id, sigma_value, Data.Analyzed, Compound))
data1$Data.Analyzed[data1$Data.Analyzed != "Joint Analysis"] <- "Ind Analysis"
data1 <- data1 %>% pivot_wider(names_from = Data.Analyzed, values_from = sigma_value)
data1 <- data1 %>% filter(sigma_id != "sigma2.14")
data1$`Joint Analysis` <- lapply(data1$`Joint Analysis`,as.numeric)
data1$`Ind Analysis` <- lapply(data1$`Ind Analysis`,as.numeric)
data1$model <- "1-Compartment"

split_list_2 <- split(data2, data2$Compound)
rep_sigma_2 <- lapply(split_list_2, find_rep_sigma)
data2 <- do.call(rbind, rep_sigma_2)
data2 <- subset(data2, select = c(param.value.type, sigma_id, sigma_value, Data.Analyzed, Compound))
data2$Data.Analyzed[data2$Data.Analyzed != "Joint Analysis"] <- "Ind Analysis"
data2 <- data2 %>% pivot_wider(names_from = Data.Analyzed, values_from = sigma_value)
data2 <- data2 %>% filter(sigma_id != "sigma2.14")
data2$`Joint Analysis` <- lapply(data2$`Joint Analysis`,as.numeric)
data2$`Ind Analysis` <- lapply(data2$`Ind Analysis`,as.numeric)
data2$model <- "2-Compartment"

data <- as.data.table(rbind(data1, data2))

p <- ggplot(data, aes(x = `Ind Analysis`, y = `Joint Analysis`)) +
  geom_point() +
  scale_y_log10() +
  scale_x_log10() +
  geom_abline(slope = 1) +
  facet_wrap(. ~ model)
p
```

```{r, make_halflife_count_histogram}

###########
### one compartment
###########

##################
##################

raw_data1 <- raw_1comp

##################
##################

pk_data1 <- pk_output_1comp %>% 
  filter(param.value.type == "Fitted geometric mean" & Data.Analyzed != "Joint Analysis")

pk_data1$X <- NULL


raw_data1$Reference <- as.character(raw_data1$Reference)

raw_data1 <- dplyr::select(raw_data1, -c("kelim",
                                         "Vdist",
                                         "Fgutabs",
                                         "kgutabs"))

# pk_data2 <- pk_output_2comp_12212021

full_data_1 <- left_join(raw_data1, pk_data1, by = c("Compound", "CAS", "Reference"))

full_data_1 <- full_data_1 %>% filter(AIC != Inf)


find_halflife_count <- function(data) {
  
  data_subset <- data %>% filter(!is.na(Value))
  
  max_time <- max(unique(data_subset$Time))
  
  data$halflife_count <- max_time/data$halflife
  
  return(data)
  
}

split_full_data_1 <- split(full_data_1, list(full_data_1$Compound,
                                             full_data_1$Reference,
                                             full_data_1$CAS,
                                             full_data_1$Dose,
                                             full_data_1$Species.x,
                                             full_data_1$Route,
                                             full_data_1$Media),
                           drop = TRUE)

full_data_1_hl <- lapply(split_full_data_1, find_halflife_count)

full_data_1_hl <- do.call(rbind, full_data_1_hl)


full_data_1_hl <- full_data_1_hl %>%
  distinct(Compound,
           Reference,
           CAS,
           Dose,
           Species.x,
           Route,
           Media,
           halflife_count)

full_data_1_hl$model <- "1-Compartment"

###########
### two compartment
###########

##################
##################

raw_data2 <- raw_2comp

pk_data2 <- pk_output_2comp %>% 
  filter(param.value.type == "Fitted geometric mean" & Data.Analyzed != "Joint Analysis")

##################
##################

pk_data2$X <- NULL


raw_data2$Reference <- as.character(raw_data2$Reference)

raw_data2 <- dplyr::select(raw_data2, -c("kelim", 
                                         "Vdist", 
                                         "Fgutabs", 
                                         "kgutabs",
                                         "V1",
                                         "Ralphatokelim",
                                         "Fbetaofalpha"))

# pk_data2 <- pk_output_2comp_12212021

full_data_2 <- left_join(raw_data2, pk_data2, by = c("Compound", "CAS", "Reference"))

full_data_2 <- full_data_2 %>% filter(AIC != Inf)


find_halflife_count <- function(data) {
  
  data_subset <- data %>% filter(!is.na(Value))
  
  max_time <- max(unique(data_subset$Time))
  
  data$halflife_count <- max_time/data$halflife
  
  return(data)
  
}

split_full_data_2 <- split(full_data_2, list(full_data_2$Compound,
                                             full_data_2$Reference,
                                             full_data_2$CAS,
                                             full_data_2$Dose,
                                             full_data_2$Species.x,
                                             full_data_2$Route,
                                             full_data_2$Media),
                           drop = TRUE)

full_data_2_hl <- lapply(split_full_data_2, find_halflife_count)

full_data_2_hl <- do.call(rbind, full_data_2_hl)


full_data_2_hl <- full_data_2_hl %>%
  distinct(Compound,
           Reference,
           CAS,
           Dose,
           Species.x,
           Route,
           Media,
           halflife_count)

full_data_2_hl$model <- "2-Compartment"

###########
###########
###########

full_data_hl <- rbind(full_data_1_hl, full_data_2_hl)

###########

p <- ggplot(data = full_data_hl, mapping = aes(x = halflife_count)) +
  geom_histogram() +
  scale_x_log10() +
  xlab("halflife count") + 
  theme_bw() +
  # geom_vline(xintercept = 330.7598,
  #            color = "red",
  #            linetype = "dashed") + 
  facet_wrap(. ~ model)
p
```

```{r, make_max_loq_histogram}

###############
###############

raw_data1 <- raw_1comp

###############
###############

find_normalized_max <- function(data) {
  
  data$normalized_max <- max(data$Value, na.rm = TRUE)/data$LOQ
  
  return(data)
  
}

split_df_1 <- split(raw_data1, list(raw_data1$Compound,
                                    raw_data1$Reference,
                                    raw_data1$CAS,
                                    raw_data1$Dose,
                                    raw_data1$Species,
                                    raw_data1$Route,
                                    raw_data1$Media),
                    drop = TRUE)

raw_data1_normalized_max <- lapply(split_df_1, find_normalized_max)

raw_data1_normalized_max <- do.call(rbind, raw_data1_normalized_max)

raw_data1_normalized_max <- raw_data1_normalized_max %>%
  distinct(Compound,
           Reference,
           CAS,
           Dose,
           Species,
           Route,
           Media,
           normalized_max)

p <- ggplot(data = raw_data1_normalized_max, mapping = aes(x = normalized_max)) +
  geom_histogram(bins = 15) +
  scale_x_log10() +
  xlab("Max Concentration / LOQ") + 
  theme_bw()
# geom_vline(xintercept = 24.8482,
#            color = "red",
#            linetype = "dashed")
p
```

```{r, make_mean_loq_histogram}

###############
###############

raw_data1 <- raw_1comp

###############
###############

find_normalized_mean <- function(data) {
  
  data$normalized_mean <- mean(data$Value, na.rm = TRUE)/data$LOQ
  
  return(data)
  
}

split_df_1 <- split(raw_data1, list(raw_data1$Compound,
                                    raw_data1$Reference,
                                    raw_data1$CAS,
                                    raw_data1$Dose,
                                    raw_data1$Species,
                                    raw_data1$Route,
                                    raw_data1$Media),
                    drop = TRUE)

raw_data1_normalized_mean <- lapply(split_df_1, find_normalized_mean)

raw_data1_normalized_mean <- do.call(rbind, raw_data1_normalized_mean)

raw_data1_normalized_mean <- raw_data1_normalized_mean %>%
  distinct(Compound,
           Reference,
           CAS,
           Dose,
           Species,
           Route,
           Media,
           normalized_mean)

p <- ggplot(data = raw_data1_normalized_mean, mapping = aes(x = normalized_mean)) +
  geom_histogram(bins = 15) +
  scale_x_log10() +
  xlab("Mean Concentration / LOQ") + 
  theme_bw()
# geom_vline(xintercept = 24.8482,
#            color = "red",
#            linetype = "dashed")
p
```

```{r, make_model_params_table, eval = FALSE}

### this code almost entirely is imported from John's bake-off RMarkdown file
### what this produces is a table of compounds that were fit by at least one of the models
### AICs for both models are reported, and subsequent parameter values correspond to the model with the lower AIC

###################
###################

pk_data1 <- pk_output_1comp
# pk_data1 <- pk_output_1comp_12212021 

pk_data2 <- pk_output_2comp
# pk_data2 <- pk_output_2comp_12212021 

###################
###################

pk_data1$sigma_id <- NULL
pk_data1$sigma_value <- NULL
pk_data2$sigma_id <- NULL
pk_data2$sigma_value <- NULL

pk_data1 <- distinct(pk_data1)
pk_data2 <- distinct(pk_data2)

fits1comp <- subset(pk_data1, is.finite(AIC) & AIC < 10^4)
fits2comp <- subset(pk_data2, is.finite(AIC) & AIC < 10^4)

#How many chemicals have 1 or 2 compartment fits:
length(unique(c(fits1comp$CAS,fits2comp$CAS)))

fittable <- NULL
# test <- function(fits1comp, fits2comp) {
for (this.cas in unique(c(fits1comp$CAS,fits2comp$CAS)))
{ 
  # print(this.cas)
  # if (this.cas == "123-91-1") browser()
  if (this.cas %in% fits1comp$CAS) this.compound <- fits1comp[
    fits1comp$CAS==this.cas,"Compound"][1]
  else this.compound <- fits2comp[
    fits2comp$CAS==this.cas,"Compound"][1]
  
  this.data.1comp <- subset(fits1comp,CAS==this.cas)
  this.data.2comp <- subset(fits2comp,CAS==this.cas)
  
  for (this.species in unique(tolower(c(
    this.data.1comp$Species,
    this.data.2comp$Species))))
  {
    Vdist.1comp <- NA
    kelim.1comp <- NA
    Vdist.2comp <- NA
    kelim.2comp <- NA
    
    this.data.1comp.species <- subset(this.data.1comp,tolower(Species)==this.species)
    this.data.2comp.species <- subset(this.data.2comp,tolower(Species)==this.species)
    
    this.row <- data.frame(
      Compound=this.compound,
      CAS=this.cas,
      Species=this.species,
      Reference=NA,
      AIC.1comp=NA,
      AIC.2comp=NA,
      Model=NA,
      Vdist=NA,
      kelim=NA)
    
    if (this.cas %in% fits1comp$CAS)
    {
      this.data.1comp.species <- subset(this.data.1comp.species,
                                        param.value.type=="Fitted geometric mean")
      
      # If more than one source, require that the joint analysis worked:
      if (dim(this.data.1comp.species)[1]>1)
      {
        this.data.1comp.species<- subset(this.data.1comp.species, 
                                         Data.Analyzed=="Joint Analysis")
      }
      if (dim(this.data.1comp.species)[1]>0) 
      {
        if (nrow(this.data.1comp.species) > 1) {
          this.data.1comp.species <- this.data.1comp.species[1, ]
        }
        
        this.row$AIC.1comp <- this.data.1comp.species$AIC
        Vdist.1comp <- this.data.1comp.species$Vdist
        kelim.1comp <- this.data.1comp.species$kelim
        this.row$Reference <- this.data.1comp.species$Reference
      }
    }
    
    if (this.cas %in% fits2comp$CAS)
    {
      this.data.2comp.species <- subset(this.data.2comp.species,
                                        param.value.type=="Fitted geometric mean")
      
      # If more than one source, require that the joint analysis worked:
      if (dim(this.data.2comp.species)[1]>1)
      {
        this.data.2comp.species <- subset(this.data.2comp.species, 
                                          Data.Analyzed=="Joint Analysis")
      }
      if (dim(this.data.2comp.species)[1]>0) 
      {
        if(nrow(this.data.2comp.species) > 1 ) {
          this.data.2comp.species <- this.data.2comp.species[1, ]
        }
        this.row$AIC.2comp <- this.data.2comp.species$AIC
        Vdist.2comp <- this.data.2comp.species$Vss
        kelim.2comp <- this.data.2comp.species$kelim
        this.row$Reference <- this.data.2comp.species$Reference
      }
    }
    
    if (!is.na(this.row$AIC.1comp))
    {
      if (!is.na(this.row$AIC.2comp))
      {
        if (this.row$AIC.1comp < this.row$AIC.2comp)
        {
          this.row$Model <- "1Comp"
        } else this.row$Model <- "2Comp"
      } else this.row$Model <- "1Comp"
    } else if (!is.na(this.row$AIC.2comp))
    {
      this.row$Model <- "2Comp"
    }
    
    if (!is.na(this.row$Model))
      if (this.row$Model == "1Comp")
      {
        this.row$Vdist <- Vdist.1comp
        this.row$kelim <- kelim.1comp
      } else 
      {
        this.row$Vdist <- Vdist.2comp
        this.row$kelim <- kelim.2comp
      }      
    
    fittable <- rbind(fittable,this.row)
  }
}

# debug(test)
# test(fits1comp, fits2comp)
fittable$halflife <- log(2)/fittable$kelim

#Lets only keep chemicals where we can fit a PK model:
fittable <- subset(fittable, !is.na(Model))

for (this.col in c("AIC.1comp","AIC.2comp","Vdist","kelim","halflife"))
  fittable[,this.col] <- signif(as.numeric(fittable[,this.col]),4)

# We have parameters estimated for 86 chemicals:
dim(fittable)[1]

### compounds fit better by flat model should be removed
# if present in fittable
### some are only fit by the flat model,
# but some are fit just fit better by the flat model

# these are
# hexachlorobenzene -- nevermind, for the joint 1comp does best
# phenolphthalein glucuronide
# tamoxifen
# 2,3,7,8-tetrachlorodibenzo-p-dioxin
# imidacloprid", # well this one is only fit by the flat,
# so isn't present anyway

### when I take these out, 48 1 compartment best fits, 59 2 compartment, 107 total

### I also manually checked all Joint Analysis compounds 
# to make sure no joint flat models performed better
# none did

# write.csv(fittable, file = "inst/ext/model_params_table_04182022.csv", row.names = FALSE)

```

```{r, make_no_fit_table}

##################
##################

pk_data1 <- as.data.table(pk_output_1comp)
pk_data2 <- as.data.table(pk_output_2comp)

##################
##################

pk_data1 <- pk_data1 %>%
  filter(param.value.type == "Fitted geometric mean") %>%
  dplyr::select(c("Compound", "CAS", "Reference", "AIC")) %>%
  mutate(model = "1-Compartment")

pk_data2 <- pk_data2 %>%
  filter(param.value.type == "Fitted geometric mean") %>%
  dplyr::select(c("Compound", "CAS", "Reference", "AIC")) %>%
  mutate(model = "2-Compartment")

pk_all <- rbind(pk_data1, pk_data2)

### loop that says if a compound has any references that do not have AIC of Inf, it was a fit compound
this.compound.list <- list()
for (this.compound in unique(pk_all[, Compound])) {
  
  this.compound.data <- pk_all[Compound == this.compound]
  this.compound.data$AIC[is.na(this.compound.data$AIC)] <- Inf
  
  if(any(this.compound.data$AIC != Inf)) {
    this.compound.data$status <- "good fit"
  } else {
    this.compound.data$status <- "bad fit"
  }
  
  this.compound.list[[this.compound]] <- this.compound.data
  
}

pk_all <- do.call(rbind, this.compound.list)

pk_all <- pk_all %>%
  filter(status == "bad fit") %>% ### only want bad fit
  mutate(status = NULL) %>% ### get rid of status column
  group_by(Compound) %>%  
  filter(n() == 2) %>% ### group_by compound and only keep compounds with two observations, aka neither model worked
  mutate(model = NULL) %>% ### get rid of model column
  distinct() ### discard repeated compound names

# write.csv(pk_all, file = "inst/ext/no_fit_table_03012022.csv", row.names = FALSE)
```

```{r, compare_AIC}

##################
##################

pk_data1 <- pk_output_1comp

pk_data2 <- pk_output_2comp

pk_data_flat <- pk_output_flat %>%
  filter(param.value.type == "Predicted" | param.value.type == "Fitted geometric mean" | param.value.type == "Fitted geometric std dev")

##################
##################

### make both data.frames have the same column names so they are rbind-able
pk_data1 <- pk_data1[, intersect(intersect(colnames(pk_data2), colnames(pk_data_flat)), colnames(pk_data1))]
pk_data2 <- pk_data2[, intersect(intersect(colnames(pk_data1), colnames(pk_data_flat)), colnames(pk_data2))]
pk_data_flat <- pk_data_flat[, intersect(intersect(colnames(pk_data1), colnames(pk_data2)), colnames(pk_data_flat))]

pk_data1 <- pk_data1 %>%
  rename(LogLikelihood_1 = LogLikelihood,
         AIC_1 = AIC,
         sigma_value_1 = sigma_value) %>%
  mutate(model = NULL) %>%
  mutate(model.type = NULL)

pk_data2 <- pk_data2 %>%
  rename(LogLikelihood_2 = LogLikelihood,
         AIC_2 = AIC,
         sigma_value_2 = sigma_value) %>%
  mutate(model = NULL) %>%
  mutate(model.type = NULL)

pk_data_flat <- pk_data_flat %>%
  rename(LogLikelihood_flat = LogLikelihood,
         AIC_flat = AIC,
         sigma_value_flat = sigma_value) %>%
  mutate(model = NULL) %>%
  mutate(model.type = NULL)

pk_all <- left_join(pk_data1, pk_data2, by = c("CAS",
                                               "Species",
                                               "param.value.type",
                                               "sigma_id",
                                               "Reference",
                                               "Data.Analyzed",
                                               "Compound"))

pk_all <- left_join(pk_all, pk_data_flat, by = c("CAS",
                                                 "Species",
                                                 "param.value.type",
                                                 "sigma_id",
                                                 "Reference",
                                                 "Data.Analyzed",
                                                 "Compound"))

pk_all <- subset(pk_all, select = c(CAS, Species, Compound, Reference, AIC_1, AIC_2, AIC_flat))

pk_all <- distinct(pk_all)

pk_all$AIC_1[pk_all$AIC_1 == Inf] <- NA
pk_all$AIC_2[pk_all$AIC_2 == Inf] <- NA
pk_all$AIC_flat[pk_all$AIC_flat == Inf] <- NA

pk_all <- pk_all %>%
  mutate(flat_lowest = ifelse(AIC_flat < AIC_1 & AIC_flat < AIC_2, 1, 0)) %>%
  mutate(flat_better_than_1 = ifelse(AIC_flat < AIC_1 & AIC_flat > AIC_2, 1, 0)) %>%
  mutate(flat_better_than_2 = ifelse(AIC_flat > AIC_1 & AIC_flat < AIC_2, 1, 0))

pk_just_bad <- pk_all %>%
  filter(flat_lowest == 1 | flat_better_than_1 == 1 | flat_better_than_2 == 1)
```

```{r, lombardo_comparisons}

##################
##################

pk_data1 <- pk_output_1comp
# pk_data1 <- pk_output_1comp_04282022


# pk_data1$Vdist <- log(pk_data1$Vdist)

pk_lombardo <- pk_lombardo

##################
##################

pk_data1 <- pk_data1 %>%
  filter(param.value.type == "Fitted geometric mean")
         # , CAS != "50-49-7", CAS != "106266-06-2")
# , Species == "human")

pk_all <- left_join(all.fit.table, pk_lombardo, by = c("CAS" = "CAS #"))

pk_all <- pk_all %>%
  filter(!is.na(`human VDss (L/kg)`), 
         !is.na(`human CL (mL/min/kg)`))

pk_all$`human CL (L/hr/kg)` <- pk_all$`human CL (mL/min/kg)` * 60 / 1000
pk_all$CLtot <- pk_all$Vdist*pk_all$kelim
pk_all$Vdist_norm <- abs(pk_all$Vdist / pk_all$`human VDss (L/kg)`)
pk_all$CLtot_norm <- abs(pk_all$CLtot / pk_all$`human CL (L/hr/kg)`)
pk_all$halflife_norm <- abs(pk_all$halflife / pk_all$`terminal  t1/2 (h)`)

pk_all$mae <- rowMeans(pk_all[, c("Vdist_norm", "CLtot_norm", "halflife_norm")])


### volume of distribution comparison
p1 <- ggplot(pk_all, aes(x = Vdist, y = `human VDss (L/kg)`)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  geom_abline(slope = 1, intercept = 0)

p1

### half-life comparision
p2 <- ggplot(pk_all, aes(x = halflife, y = `terminal  t1/2 (h)`)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  geom_abline(slope = 1, intercept = 0)

p2

### clearance comparison

### convert to same units

p3 <- ggplot(data = pk_all, mapping = aes(x = CLtot, y = `human CL (L/hr/kg)`)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  geom_abline(slope = 1, intercept = 0)

p3


```

<!-- # ```{r, make_model_params_table, eval = FALSE} -->
<!-- #  -->
<!-- # ### this code almost entirely is imported from John's bake-off RMarkdown file -->
<!-- # ### what this produces is a table of compounds that were fit by at least one of the models -->
<!-- # ### AICs for both models are reported, and subsequent parameter values correspond to the model with the lower AIC -->
<!-- #  -->
<!-- # ################### -->
<!-- # ################### -->
<!-- #  -->
<!-- # pk_data1 <- pk_output_1comp_04142022  -->
<!-- # # pk_data1 <- pk_output_1comp_12212021  -->
<!-- #  -->
<!-- # pk_data2 <- pk_output_2comp_04142022  -->
<!-- # # pk_data2 <- pk_output_2comp_12212021  -->
<!-- #  -->
<!-- # pk_data_flat <- pk_output_flat_04142022 -->
<!-- #  -->
<!-- # ################### -->
<!-- # ################### -->
<!-- #  -->
<!-- # pk_data1$sigma_id <- NULL -->
<!-- # pk_data1$sigma_value <- NULL -->
<!-- # pk_data2$sigma_id <- NULL -->
<!-- # pk_data2$sigma_value <- NULL -->
<!-- # pk_data_flat$sigma_id <- NULL -->
<!-- # pk_data_flat$sigma_value <- NULL -->
<!-- #  -->
<!-- # pk_data1 <- distinct(pk_data1) -->
<!-- # pk_data2 <- distinct(pk_data2) -->
<!-- # pk_data_flat <- distinct(pk_data_flat) -->
<!-- #  -->
<!-- # fits1comp <- subset(pk_data1, is.finite(AIC) & AIC < 10^4) -->
<!-- # fits2comp <- subset(pk_data2, is.finite(AIC) & AIC < 10^4) -->
<!-- # fitsflat <- subset(pk_data_flat, is.finite(AIC) & AIC < 10^4) -->
<!-- #  -->
<!-- # #How many chemicals have 1 or 2 compartment fits: -->
<!-- # length(unique(c(fits1comp$CAS,fits2comp$CAS,fitsflat$CAS))) -->
<!-- #  -->
<!-- # fittable <- NULL -->
<!-- # # test <- function(fits1comp, fits2comp, fitsflat) { -->
<!-- #   for (this.cas in unique(c(fits1comp$CAS,fits2comp$CAS, fitsflat$CAS))) -->
<!-- #   { print(this.cas) -->
<!-- #     # if (this.cas == "96-47-9") browser() -->
<!-- #     if (this.cas %in% fits1comp$CAS) this.compound <- fits1comp[ -->
<!-- #       fits1comp$CAS==this.cas,"Compound"][1] -->
<!-- #     else if (this.cas %in% fits2comp$CAS) this.compound <- fits2comp[ -->
<!-- #       fits2comp$CAS==this.cas,"Compound"][1] -->
<!-- #     else if (this.cas %in% fitsflat$CAS) this.compound <- fitsflat[ -->
<!-- #       fitsflat$CAS==this.cas,"Compound"][1] -->
<!-- #      -->
<!-- #     this.data.1comp <- subset(fits1comp,CAS==this.cas) -->
<!-- #     this.data.2comp <- subset(fits2comp,CAS==this.cas) -->
<!-- #     this.data.flat <- subset(fitsflat,CAS==this.cas) -->
<!-- #      -->
<!-- #     for (this.species in unique(tolower(c( -->
<!-- #       this.data.1comp$Species, -->
<!-- #       this.data.2comp$Species, -->
<!-- #       this.data.flat$Species)))) -->
<!-- #     { -->
<!-- #       Vdist.1comp <- NA -->
<!-- #       kelim.1comp <- NA -->
<!-- #       Vdist.2comp <- NA -->
<!-- #       kelim.2comp <- NA -->
<!-- #       A.flat <- NA -->
<!-- #        -->
<!-- #       this.data.1comp.species <- subset(this.data.1comp,tolower(Species)==this.species) -->
<!-- #       this.data.2comp.species <- subset(this.data.2comp,tolower(Species)==this.species) -->
<!-- #       this.data.flat.species <- subset(this.data.flat, tolower(Species)==this.species) -->
<!-- #        -->
<!-- #       this.row <- data.frame( -->
<!-- #         Compound=this.compound, -->
<!-- #         CAS=this.cas, -->
<!-- #         Species=this.species, -->
<!-- #         Reference=NA, -->
<!-- #         AIC.1comp=NA, -->
<!-- #         AIC.2comp=NA, -->
<!-- #         Model=NA, -->
<!-- #         Vdist=NA, -->
<!-- #         kelim=NA) -->
<!-- #        -->
<!-- #       if (this.cas %in% fits1comp$CAS) -->
<!-- #       { -->
<!-- #         this.data.1comp.species <- subset(this.data.1comp.species, -->
<!-- #                                           param.value.type=="Fitted geometric mean") -->
<!-- #          -->
<!-- #         # If more than one source, require that the joint analysis worked: -->
<!-- #         if (dim(this.data.1comp.species)[1]>1) -->
<!-- #         { -->
<!-- #           this.data.1comp.species<- subset(this.data.1comp.species,  -->
<!-- #                                            Data.Analyzed=="Joint Analysis") -->
<!-- #         } -->
<!-- #         if (dim(this.data.1comp.species)[1]>0)  -->
<!-- #         { -->
<!-- #           if (nrow(this.data.1comp.species) > 1) { -->
<!-- #             this.data.1comp.species <- this.data.1comp.species[1, ] -->
<!-- #           } -->
<!-- #            -->
<!-- #           this.row$AIC.1comp <- this.data.1comp.species$AIC -->
<!-- #           Vdist.1comp <- this.data.1comp.species$Vdist -->
<!-- #           kelim.1comp <- this.data.1comp.species$kelim -->
<!-- #           this.row$Reference <- this.data.1comp.species$Reference -->
<!-- #         } -->
<!-- #       } -->
<!-- #        -->
<!-- #       if (this.cas %in% fits2comp$CAS) -->
<!-- #       { -->
<!-- #         this.data.2comp.species <- subset(this.data.2comp.species, -->
<!-- #                                           param.value.type=="Fitted geometric mean") -->
<!-- #          -->
<!-- #         # If more than one source, require that the joint analysis worked: -->
<!-- #         if (dim(this.data.2comp.species)[1]>1) -->
<!-- #         { -->
<!-- #           this.data.2comp.species <- subset(this.data.2comp.species,  -->
<!-- #                                             Data.Analyzed=="Joint Analysis") -->
<!-- #         } -->
<!-- #         if (dim(this.data.2comp.species)[1]>0)  -->
<!-- #         { -->
<!-- #           if(nrow(this.data.2comp.species) > 1 ) { -->
<!-- #             this.data.2comp.species <- this.data.2comp.species[1, ] -->
<!-- #           } -->
<!-- #           this.row$AIC.2comp <- this.data.2comp.species$AIC -->
<!-- #           Vdist.2comp <- this.data.2comp.species$Vss -->
<!-- #           kelim.2comp <- this.data.2comp.species$kelim -->
<!-- #           this.row$Reference <- this.data.2comp.species$Reference -->
<!-- #         } -->
<!-- #       } -->
<!-- #        -->
<!-- #       if (this.cas %in% fitsflat$CAS) -->
<!-- #       { -->
<!-- #         this.data.flat.species <- subset(this.data.flat.species, -->
<!-- #                                          param.value.type=="Fitted geometric mean") -->
<!-- #          -->
<!-- #         # If more than one source, require that the joint analysis worked: -->
<!-- #         if (dim(this.data.flat.species)[1]>1) -->
<!-- #         { -->
<!-- #           this.data.flat.species <- subset(this.data.flat.species,  -->
<!-- #                                            Data.Analyzed=="Joint Analysis") -->
<!-- #         } -->
<!-- #         if (dim(this.data.flat.species)[1]>0)  -->
<!-- #         { -->
<!-- #           if(nrow(this.data.flat.species) > 1 ) { -->
<!-- #             this.data.flat.species <- this.data.flat.species[1, ] -->
<!-- #           } -->
<!-- #           this.row$AIC.flat <- this.data.flat.species$AIC -->
<!-- #           A.flat <- this.data.flat.species$A -->
<!-- #           this.row$Reference <- this.data.flat.species$Reference -->
<!-- #         } -->
<!-- #       } -->
<!-- #       ######################## -->
<!-- #       ######################### -->
<!-- #        -->
<!-- #       if(!"AIC.flat" %in% names(this.row)) this.row <- this.row %>%  -->
<!-- #         add_column(AIC.flat = NA) -->
<!-- #        -->
<!-- #       if(!"AIC.1comp" %in% names(this.row)) this.row <- this.row %>%  -->
<!-- #         add_column(AIC.1comp = NA) -->
<!-- #        -->
<!-- #       if(!"AIC.2comp" %in% names(this.row)) this.row <- this.row %>%  -->
<!-- #         add_column(AIC.2comp = NA) -->
<!-- #        -->
<!-- #       this.row <- this.row %>% mutate(Model = case_when(AIC.1comp < AIC.2comp &  -->
<!-- #                                                           AIC.1comp < AIC.flat ~ "1Comp", -->
<!-- #                                                         AIC.2comp < AIC.1comp & -->
<!-- #                                                           AIC.2comp < AIC.flat ~ "2Comp", -->
<!-- #                                                         AIC.flat < AIC.1comp & -->
<!-- #                                                           AIC.flat < AIC.2comp ~ "Null", -->
<!-- #                                                          -->
<!-- #                                                         !is.na(AIC.1comp) & is.na(AIC.2comp) & -->
<!-- #                                                           is.na(AIC.flat) ~ "1Comp", -->
<!-- #                                                         !is.na(AIC.2comp) & is.na(AIC.1comp) &  -->
<!-- #                                                           is.na(AIC.flat) ~ "2Comp", -->
<!-- #                                                         !is.na(AIC.flat) & is.na(AIC.1comp) &  -->
<!-- #                                                           is.na(AIC.2comp) ~ "Null", -->
<!-- #                                                          -->
<!-- #                                                         is.na(AIC.1comp) & -->
<!-- #                                                           AIC.flat < AIC.2comp ~ "Null", -->
<!-- #                                                         is.na(AIC.1comp) & -->
<!-- #                                                           AIC.2comp < AIC.flat ~ "2Comp", -->
<!-- #                                                         is.na(AIC.2comp) & -->
<!-- #                                                           AIC.flat < AIC.1comp ~ "Null", -->
<!-- #                                                         is.na(AIC.2comp) & -->
<!-- #                                                           AIC.1comp < AIC.flat ~ "1Comp", -->
<!-- #                                                         is.na(AIC.flat) & -->
<!-- #                                                           AIC.1comp < AIC.2comp ~"1Comp", -->
<!-- #                                                         is.na(AIC.flat) & -->
<!-- #                                                           AIC.2comp <AIC.1comp ~"2Comp")) -->
<!-- #        -->
<!-- #        -->
<!-- #       fittable <- rbind(fittable,this.row) -->
<!-- #     } -->
<!-- #   } -->
<!-- # # } -->
<!-- # # debug(test) -->
<!-- # # test(fits1comp, fits2comp, fitsflat) -->
<!-- # fittable$halflife <- log(2)/fittable$kelim -->
<!-- #  -->
<!-- # #Lets only keep chemicals where we can fit a PK model: -->
<!-- # fittable <- subset(fittable, !is.na(Model)) -->
<!-- #  -->
<!-- # # for (this.col in c("AIC.1comp","AIC.2comp","Vdist","kelim","halflife")) -->
<!-- # #   fittable[,this.c=-] <- signif(as.numeric(fittable[,this.col]),4) -->
<!-- #  -->
<!-- # # We have parameters estimated for 86 chemicals: -->
<!-- # dim(fittable)[1] -->
<!-- #  -->
<!-- # # write.csv(fittable, file = "inst/ext/model_params_table_04182022.csv", row.names = FALSE) -->
<!-- #  -->
<!-- # ``` -->



