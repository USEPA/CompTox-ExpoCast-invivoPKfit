% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pk_faceted_methods_coef_sd.R,
%   R/pk_methods_coef_sd.R
\name{coef_sd.pk}
\alias{coef_sd.pk}
\title{coef_sd}
\usage{
\method{coef_sd}{pk}(obj, model = NULL, method = NULL, suppress.messages = TRUE)

\method{coef_sd}{pk}(obj, model = NULL, method = NULL, suppress.messages = TRUE)
}
\arguments{
\item{obj}{A [pk] object}

\item{model}{Optional: Specify one or more of the fitted models whose
coefficients to return. If NULL (the default), coefficients will be
returned for all of the models in `obj$stat_model`.}

\item{method}{Optional: Specify one or more of the [optimx::optimx()] methods
whose coefficients to return. If NULL (the default), coefficients will be
returned for all of the models in `obj$settings_optimx$method`.}

\item{suppress.messages}{Logical. `TRUE` (the default) to suppress
informative messages. `FALSE` to see them.}
}
\value{
A [tibble::tibble()] grouped by the faceting variables with a new variable ` coef_sd ` containing the results of applying [coef_sd.pk()] to each item in the list column of [pk()] objects, `obj$pk_object`

A named list of numeric matrixes. There is one list element named for
  each model in `model`. Each list element is a matrix with as many rows as
  items in `method`. The row names are the method names. The matrix column
  names are the names of the fitted parameters, including any error standard
  deviation hyperparameters (whose names begin with "sigma").
}
\description{
coef_sd for pk_faceted objects

Extract coefficient/parameter standard deviations from a fitted `pk` object
}
\details{
The coefficient standard deviations are estimated by computing a numerical
approximation to the model Hessian (the matrix of second derivatives of the
model objective function with respect to each model parameter) and then
attempting to invert it. This procedure yields a variance/covariance matrix
for the model parameters. The square root of the diagonal elements of this
matrix represent the parameter standard deviations.

If the Hessian is not invertible, an attempt is made to calculate a
pseudovariance matrix, following the procedure outlined in Gill & King
(2004). First, the generalized inverse of the Hessian is calculated using
[MASS::ginv()]. Then, a generalized Cholesky decomposition (to ensure
positive-definiteness) is calculated using [base::chol()] with argument
`pivot = TRUE`. The square root of the diagonal elements of this matrix
represent the parameter standard deviations.

If neither of these procedures is successful, then `NA_real_` is returned for
all coefficient standard deviations.
}
\references{
Gill J, King G. (2004) What to Do When Your Hessian is Not
  Invertible: Alternatives to Model Respecification in Nonlinear Estimation.
  Sociological Methods & Research 33(1):54-87. DOI: 10.1177/0049124103262681
}
\seealso{
Other methods for pk_faceted objects: 
\code{\link{AIC.pk}()},
\code{\link{BIC.pk}()},
\code{\link{check_needed_status.pk}()},
\code{\link{coef.pk}()},
\code{\link{compare_models.pk}()},
\code{\link{data_summary.pk}()},
\code{\link{eval_tkstats.pk}()},
\code{\link{fold_error.pk}()},
\code{\link{get_data.pk}()},
\code{\link{get_data_group.pk}()},
\code{\link{get_data_info.pk}()},
\code{\link{get_data_original.pk}()},
\code{\link{get_data_sigma_group.pk}()},
\code{\link{get_error_group.pk}()},
\code{\link{get_fit.pk}()},
\code{\link{get_mapping.pk}()},
\code{\link{get_nca.pk}()},
\code{\link{get_prefit.pk}()},
\code{\link{get_scale_conc.pk}()},
\code{\link{get_scale_time.pk}()},
\code{\link{get_settings_data_info.pk}()},
\code{\link{get_settings_optimx.pk}()},
\code{\link{get_settings_preprocess.pk}()},
\code{\link{get_stat_error_model.pk}()},
\code{\link{get_stat_model.pk}()},
\code{\link{get_status.pk}()},
\code{\link{get_tkstats.pk}()},
\code{\link{get_winning_model.pk}()},
\code{\link{is.pk}()},
\code{\link{logLik.pk}()},
\code{\link{nca.pk}()},
\code{\link{plot.pk}()},
\code{\link{predict.pk}()},
\code{\link{preprocess_data.pk_faceted}()},
\code{\link{residuals.pk}()},
\code{\link{rmse.pk}()},
\code{\link{rsq.pk}()},
\code{\link{subtract_pkproto.pk}()},
\code{\link{summary.pk}()}

Other methods for fitted pk objects: 
\code{\link{AIC.pk}()},
\code{\link{BIC.pk}()},
\code{\link{coef.pk}()},
\code{\link{eval_tkstats.pk}()},
\code{\link{get_fit.pk}()},
\code{\link{get_tkstats.pk}()},
\code{\link{logLik.pk}()},
\code{\link{predict.pk}()},
\code{\link{residuals.pk}()},
\code{\link{rmse.pk}()},
\code{\link{rsq.pk}()}
}
\author{
Caroline Ring
}
\concept{methods for fitted pk objects}
\concept{methods for pk_faceted objects}
