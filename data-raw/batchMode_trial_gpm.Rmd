---
title: "PK object batch mode trial"
author: "Gilberto Padilla Mercado"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)

library(tidyverse, quietly = TRUE)
devtools::load_all() # Loads the invivopkfit package in feature/pkS3obj_facet branch
tidyverse_conflicts()
```

## Working with one DTXSID + Species combination

The first step is understanding how to work with a single DTXSID + Species combination.
Once we know how to do this, it will be easier to apply it to (potentially)
a list of these objects in a vectorized fashion.
Here I subset the `cvt` object and use that as my working data.

```{r data_loading}
# There are 103 unique chemicals in this object
cvt %>% pull(chemicals_analyzed.dsstox_substance_id) %>%
  unique() %>%
  length()

my_predata <- cvt %>%
  dplyr::filter(chemicals_analyzed.dsstox_substance_id %in% c("DTXSID0020442",
                                                              "DTXSID5032600"))


my_predata <- cvt %>%
  dplyr::filter(chemicals_analyzed.dsstox_substance_id %in% c("DTXSID3061635"))

```

Next, I want to follow the steps required for the particular analysis I would like.
In this instance, I set the optimizer to "L-BFGS-B" and dose-normalize the output.
I do not scale the time or log-transform the concentration values.
Since I would like to do a "Pooled" analysis,
I set the `error_group = vars(Chemical, Species)`.

```{r single_fit}
my_pk <- pk(data = my_predata) +
  facet_data(vars(Chemical, Species)) +
  settings_preprocess(keep_data_original = TRUE) +
  settings_optimx(method = c("L-BFGS-B", "bobyqa")) +
  scale_conc(dose_norm = TRUE, log10_trans = FALSE) +
  # scale_time() +
  # stat_model() + 
  stat_error_model(error_group = vars(Chemical, Species)) 

my_pk <- do_preprocess(my_pk)

my_pk <- do_data_info(my_pk) 
# summarizes error (Returning more or less than 1 row per summarize)

my_pk <- do_prefit(my_pk)

my_pk <- do_fit(my_pk)
```

Batch mode works! Now, I have updated the `coef`, `predict`, `rmse`, and `residuals`
methods.

```{r after_method_update}
# Changed pk_methods coef() and predict() to those above
# Ran the following after making the pk object:
devtools::load_all()

my_coefs_update <- coef(my_pk, drop_sigma = TRUE)
my_pred_update <- predict(my_pk,
                          exclude = TRUE, # add the "exclude" column to output
                          use_scale_conc = TRUE)

predict(my_pk,
        exclude = TRUE, # add the "exclude" column to output
        use_scale_conc = TRUE)


my_pred2 <- predict(my_pk,
                    newdata = data.frame(Chemical = "DTXSID2021731",
                                         Species = "rat",
                                         Route = "iv",
                                         Media = "plasma",
                                         Dose = 20,
                                         Time = 1.6,
                                         Time.Units = "hours"),
                    exclude = FALSE,
                    use_scale_conc = FALSE)

rmse(my_pk) %>% View("RMSE_test")
residuals(my_pk) %>% View("Residuals_test")

```


```{r plotting_method}


plot(my_pk, use_scale_conc = TRUE,
     print_out = TRUE, log10_C = FALSE)

my_plot <- plot(my_pk, use_scale_conc = TRUE)

# This is printable into a one file, multipage pdf
pdf(file = "C:/Users/GPADILLA/OneDrive - Environmental Protection Agency (EPA)/Profile/Documents/Code Notes/plotMethod_freeY.pdf",
    width = 10,
    height = 8)
plot(my_pk, use_scale_conc = TRUE,
     print_out = TRUE)
dev.off()

png(file = "C:/Users/GPADILLA/OneDrive - Environmental Protection Agency (EPA)/Profile/Documents/Code Notes/examplePlot.png",
    width = 8,
    height = 6,
    units = "in",
    res = 150,
    type = "cairo",
    antialias = "none")
plot(my_pk, use_scale_conc = TRUE,
     method = "L-BFGS-B",
     print_out = TRUE)[[3]]
dev.off()


```

```{r get_tkstats_logLik_methods}
my_tkstats <- get_tkstats(my_pk)

names(my_tkstats)
my_tkstats


my_logLike_update <- logLik(my_pk)




```


```{r remaining_methods}
# coef_sd
# logLik.pk

devtools::load_all()
AIC(my_pk)
BIC(my_pk)

```

The purpose of the following code is to generate data.frames with information for
all 103 chemicals in the `cvt` dataset that comes with `invivopkfit`.
I will need to do append each dataframe to the last for the outputs of the following
methods:

- `AIC()`
- `BIC()` left-joined with `AIC` output
- `get_tkstats()`

I will also have to fit these iteratively and manage the memory as part of the loop.


```{r for_loop_allDTXSIDs}

# All DTXSID
eachDTXSID <- unique(cvt$chemicals_analyzed.dsstox_substance_id)

id <- 1
AIC_BIC <- data.frame()
while (id <= 10) {
  # Establishing the loop
  DTX_set <- eachDTXSID[seq(from = id, to = id + 3)]
  DTX_set <- DTX_set[!is.na(DTX_set)]
  print(DTX_set)
  id <- id + 4
  Sys.sleep(0.5)
  
  # Subsetting cvt
  my_predata <- cvt %>%
  dplyr::filter(chemicals_analyzed.dsstox_substance_id %in% DTX_set)
  
  # Fitting loop
  my_pk <- pk(data = my_predata) +
  facet_data(vars(Chemical, Species)) +
  settings_preprocess(keep_data_original = TRUE) +
  settings_optimx(method = c("L-BFGS-B", "bobyqa")) +
  scale_conc(dose_norm = TRUE, log10_trans = FALSE) +
  # scale_time() +
  # stat_model() + 
  stat_error_model(error_group = vars(Chemical, Species)) # Pooled model

  my_pk <- do_preprocess(my_pk)
  
  my_pk <- do_data_info(my_pk) 
  # summarizes error (Returning more or less than 1 row per summarize)
  
  my_pk <- do_prefit(my_pk)
  
  my_pk <- do_fit(my_pk)
  
  
  # OUTPUTS
  # AIC/BIC
  temp_AIC <- AIC(my_pk)
  temp_BIC <- BIC(my_pk)
  temp_IC <- left_join(temp_AIC, temp_BIC)
  AIC_BIC <- bind_rows(AIC_BIC, temp_IC)
  
} # Doesn't work because something for Solvent red 1 introduces an error 


```


