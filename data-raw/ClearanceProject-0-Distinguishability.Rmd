---
title: "Sampling Clint and Funbound.plasma"
author: "Gilberto Padilla Mercado"
date: "2025-06-03"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r library_loading}
# June 6, 2025 8AM: Using httk-dev/HTTK-293 branch
# June 6, 2025 3PM: Using httk-dev/dev branch
source("data-raw/RC_comparison_bkgd.R")
library(dplyr)
library(tidyselect)
library(ggplot2)
library(patchwork)
library(parallel)
```

# Purpose

```{r set_parameters}
THIS_CHEMICAL = "DTXSID3024289" # A chemical to test
# THIS_CHEMICAL = "DTXSID50873382" # Warfarin
DOSE = 25
SPECIES = "Rat"
ROUTE = "oral"
TIMES = c(seq(0, 23.75, by = 0.25), seq(24, 72, by = 6),
          seq(96, 120, by = 24))/24
SAMPLES = 1000
VARPARS = list(Clint = 0.1)
CENSORPARS = list(Funbound.plasma = list(cv = 0.1, lod = 1E-5))
HUMAN_CLINT_FUP = TRUE
SPECIES_TEXT <- ifelse(SPECIES != "Human" && HUMAN_CLINT_FUP,
                       paste0(SPECIES, "_parHuman"),
                       SPECIES)
INVITROUV = NULL
INVITROUV_TEXT = NULL
if (!is.null(INVITROUV)) {
  INVITROUV_TEXT = "_usedINVITRO"
}
```

```{r get_chems}
chems_available <- get_cheminfo(info = "dtxsid", species = SPECIES,
                                model = "gas_pbtk") |> suppressWarnings()
```

```{r helper_functions}
# Get all simulations (restrictive and nonrestrictive)
conc_fun_wsamples <- function(
    # Parameterizing args
    dtxsid,
    species = "Human",
    default_to_human = FALSE,
    force_human = FALSE,
    # Solving args
    dose = 20, 
    route = "iv",
    times = seq(0, 48, by = 1)/24,
    # MC sampler args
    vary.params = NULL,
    censored.params = NULL,
    samples = 1000
) {
  # Decided to do both Clearances in one go
  # parameterization to be able to explicitly force human clint and fup
  
  # Parameterize
  gas_pars <- standard_parameterization(
    dtxsid = dtxsid,
    species = species,
    default_to_human = default_to_human,
    force_human = force_human
  )
  
  # SOLVE NUMERICALLY
  numerical_solution <- standard_httk_preds(parameters = gas_pars,
                                            species = species,
                                            default_to_human = default_to_human,
                                            force_human = force_human,
                                            dose = dose,
                                            route = route,
                                            times = times)
  
  mc_solutions <- standard_httk_mc(parameters = gas_pars,
                                   species = species,
                                   default_to_human = default_to_human,
                                   force_human = force_human,
                                   dose = dose,
                                   route = route,
                                   times = times,
                                   vary.params = vary.params,
                                   censored.params = censored.params,
                                   samples = samples)

  # Merge the solutions
  tmp <- merge(numerical_solution, mc_solutions)
  tmp <- subset(tmp, Time %in% times)
  
  # Time from days to hours
  tmp$Time <- janitor::round_to_fraction(tmp$Time * 24, denominator = 60)

  return(tmp)
}

```



```{r runs}

# system.time(
  test_mc_fun <- conc_fun_wsamples(
    dtxsid = "DTXSID3024289",
    times = TIMES,
    species = SPECIES,
    route = ROUTE,
    samples = SAMPLES,
    dose = DOSE,
    vary.params = VARPARS,
    censored.params = CENSORPARS,
    force_human = HUMAN_CLINT_FUP
  )
# )

# What is happening now is with parameterization, solution is higher than MC!
# But Solution is correct... MC has decreased!!!

Sys.sleep(5)
gc()

```

```{r test_plots}
# How do restrictive vs non-restrictive compare?
ggplot(test_mc_fun, aes(x = Time)) +
  geom_line(mapping = aes(y = MED_R), color = "magenta4",
            linewidth = 1, linetype = "76") +
  geom_ribbon(mapping = aes( ymin = l95_R, ymax = u95_R), linetype = "dotted",
              fill = NA, color = "magenta4") +
  geom_line(mapping = aes(y = MED_N), color = "cyan4",
            linewidth = 1, linetype = "76") +
  geom_ribbon(mapping = aes(ymin = l95_N, ymax = u95_N), linetype = "dotted",
              fill = NA, color = "cyan4") +
  geom_line(aes(y = Sol_N), linetype = "55") +
  geom_line(aes(y = Sol_R), linetype = "solid") +
  labs(y = "Concentration (mg/L)",x = "Time (hrs)",
       title = paste0(THIS_CHEMICAL, " (", DOSE, "mg/kg)"),
       subtitle = paste0("Samples: ", SAMPLES)) +
  coord_cartesian(xlim = c(0,24)) +
  theme_bw()

ggplot(test_mc_fun,
  mapping = aes(
    x = MED_N,
    y = MED_R
  )
) +
  geom_ribbon(aes(ymin = l95_R, ymax = u95_R),
              fill = "magenta4", alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0) +
  geom_ribbon(aes(ymin = l95_N, ymax = u95_N),
              fill = "cyan4", alpha = 0.5) +
  theme_bw()

```

## Overlaps of confidence intervals

A confidence interval represents our *confidence*
that the mean value of a distribution is within a
particular range. Thus when we take the *overlap*
of these intervals and divide it by the
non-overlapping areas, it is a rough representation
of how *confident* we would be in distinguishing
two sets of TK curves. I will call this the
**distinguishability**.


```{r testing_overlap}
# Overlap testing
# mat must have rownames and first row must be "Time"
args(calc_overlap)

# Test matrices
## Simple Triangle
mat_st <- matrix(c(0,0,0,2,0,4,5,0,0), nrow = 3)
rownames(mat_st) <- c("Time", "UL", "BL")
mat_st
calc_overlap(mat_st)

## Diamond (undetermined midpoint)
mat_dd <- matrix(c(0,10,0,
                   2,0,10,
                   10,10,0),
                 nrow = 3)
rownames(mat_dd) <- c("Time", "UL", "BL")
mat_dd
calc_overlap(mat_dd)
```

```{r diagnosing}
# Checking that the medians/means of samples are consistent with numerical solution
TEST_CHEMICALS <- paste0("DTXSID",
                         c("0020232", "4020458",
                           "8020541", "4022529",
                           "6022923", "3024289"))

for (this_chem in TEST_CHEMICALS) {
  solved_mc_fun <- conc_fun_wsamples(this_chem,
                                     species = SPECIES,
                                     default_to_human = FALSE,
                                     force_human = HUMAN_CLINT_FUP,
                                     vary.params = VARPARS,
                                     censored.params = CENSORPARS,
                                     dose = DOSE,
                                     route = ROUTE,
                                     times = TIMES)
  print(
    ggplot(solved_mc_fun, aes(x = Time)) +
      geom_line(mapping = aes(y = MED_R), color = "magenta4",
                linewidth = 1, linetype = "76") +
      geom_ribbon(mapping = aes( ymin = l95_R, ymax = u95_R), linetype = "dotted",
                  fill = NA, color = "magenta4") +
      geom_line(mapping = aes(y = MED_N), color = "cyan4",
                linewidth = 1, linetype = "76") +
      geom_ribbon(mapping = aes(ymin = l95_N, ymax = u95_N), linetype = "dotted",
                  fill = NA, color = "cyan4") +
      geom_line(aes(y = Sol_N), linetype = "55") +
      geom_line(aes(y = Sol_R), linetype = "solid") +
      labs(y = "Concentration (mg/L)",x = "Time (hrs)",
           title = paste0(this_chem, " (", DOSE, "mg/kg)"),
           subtitle = paste0("Samples: ", SAMPLES)) +
      theme_bw()
  )
  Sys.sleep(10)
}



```

We need to assess the distinguishability in a standard manner, with a few 
considerations. We can assess human and rat at arbitrary doses and coefficients
of variation for `Clint` and `Funbound.plasma`. However, there may be specific
doses and CVs for which we want to test. Note that there are 

```{r all_chems_fun}

assessment_fun <- function(
    x,
    species = SPECIES,
    dose = DOSE,
    route = ROUTE,
    times = TIMES,
    samples = SAMPLES,
    vary.params = VARPARS,
    censored.params = CENSORPARS,
    force_human = HUMAN_CLINT_FUP
) {
  p_df <- conc_fun_wsamples(
    dtxsid = x,
    species = species,
    dose = dose,
    route = route,
    times = times,
    samples = samples,
    vary.params = vary.params,
    censored.params = censored.params,
    force_human = force_human
  ) |> try()
  
  if (inherits(p_df, "try-error")) return("Error at solving")
  
  p_df <- p_df[-2, ] # Remove small time increment
  
  if (identical(p_df[["Sol_R"]], p_df[["Sol_N"]])) {
    # Not distinguishable by numerical solution
    hep_extr <- parameterize_gas_pbtk(
      dtxsid = x,
      species = species,
      restrictive.clearance = TRUE,
      force.human.clint.fup = force_human,
      Caco2.options = list(overwrite.invivo = TRUE)
    ) |> try()
    
    if (inherits(hep_extr, "try-error")) return("Error at  parameterizing")
    
    hep_extr <- with(
      hep_extr, 
      Clmetabolismc / (Qcardiacc * Qliverf)
    )
    if (hep_extr < 0.3) {
      return(setNames("ND_SO_low", x))
    } else if (hep_extr > 0.7) {
      return(setNames("ND_SO_hi", x))
    } else {
      return(setNames("ND_SO_mid", x))
    }
  } else if (all(with(p_df, u95_N <= l95_R))) {
    # Distinguishable, non-overlapping at all
    # Change to "Identifiable"
    return(setNames("Distinguished", x))
  } else if (any(with(p_df, u95_N > l95_R))) {
    mcmat <- data.matrix(p_df[c("Time", 
                                  "l95_R", "u95_R",
                                  "l95_N", "u95_N")])
    
    this_auc_R <- calc_overlap(mcmat[, c("Time", "l95_R", "u95_R")])
    this_auc_N <- calc_overlap(mcmat[, c("Time", "l95_N", "u95_N")])
    this_auc_B <- min(
      calc_overlap(mcmat[, c("Time", "l95_R", "u95_N")]),
      calc_overlap(mcmat[, c("Time", "l95_R", "u95_N")])
    )
    prob_auc <- signif(this_auc_B / (this_auc_R + this_auc_N - this_auc_B), 4)
    
    if (!is.nan(prob_auc) && prob_auc > 0.1) {
      # Not distinguishable by Monte Carlo simulations
      hep_extr <- parameterize_gas_pbtk(
        dtxsid = x,
        species = species,
        restrictive.clearance = TRUE,
        force.human.clint.fup = force_human,
        Caco2.options = list(overwrite.invivo = TRUE)
      ) |> try()
      
      if (inherits(hep_extr, "try-error")) return("Error at parameterizing")
      
      hep_extr <- with(
        hep_extr, 
        Clmetabolismc / (Qcardiacc * Qliverf)
      )
      if (hep_extr < 0.3) {
        return(setNames("ND_MC_low", x))
      } else if (hep_extr > 0.7) {
        return(setNames("ND_MC_hi", x))
      } else {
        return(setNames("ND_MC_mid", x))
      }
    } else {
      # Distinguishable
      return(setNames("Distinguished", x))
    }
  }
}

# PLOTTING FUNCTION
plotting_fun <- function(
    x,
    species = SPECIES,
    dose = DOSE,
    route = ROUTE,
    times = TIMES,
    samples = SAMPLES,
    vary.params = VARPARS,
    censored.params = CENSORPARS,
    force_human = HUMAN_CLINT_FUP  
) {
  p_df <- conc_fun_wsamples(
    dtxsid = x,
    species = species,
    dose = dose,
    route = route,
    times = times,
    samples = samples,
    vary.params = vary.params,
    censored.params = censored.params,
    force_human = force_human
  )
  p_df <- p_df[-2, ] # Remove small time increment
  p_df_rmse <- signif(sum(with(p_df, (Sol_R - MED_R)^2)) / NROW(p_df), 3)
  title_txt <- paste(unlist(get_chem_id(dtxsid = x))[2:3], collapse = "\n")
  
  if (identical(p_df[["Sol_R"]], p_df[["Sol_N"]])) {
    
    pl <- ggplot(p_df, aes(x = Time)) +
      geom_line(aes(y = Sol_R)) +
      geom_line(aes(y = MED_R), linetype = "44", color = "purple") +
      labs(title = title_txt,
           subtitle = paste("RMSE:", signif(p_df_rmse, 5)),
           y = "Concentration (mg/L)") +
      scale_x_continuous(breaks = seq(0,120, by = 12)) +
      theme_bw() +
      theme(plot.title = element_text(hjust = 0.5))
    
  } else {
    mcmat <- data.matrix(p_df[c("Time", 
                                  "l95_R", "u95_R",
                                  "l95_N", "u95_N")])
    
    this_auc_R <- calc_overlap(mcmat[, c("Time", "l95_R", "u95_R")])
    this_auc_N <- calc_overlap(mcmat[, c("Time", "l95_N", "u95_N")])
    this_auc_B <- min(
      calc_overlap(mcmat[, c("Time", "l95_R", "u95_N")]),
      calc_overlap(mcmat[, c("Time", "l95_R", "u95_N")])
    )
    prob_auc <- signif(this_auc_B / (this_auc_R + this_auc_N - this_auc_B), 4)
    pl <- ggplot(p_df, aes(x = Time)) +
      geom_ribbon(aes(ymin = l95_R, ymax = u95_R),
                  linetype = "44", fill = "magenta3", alpha = 0.3) +
      geom_ribbon(aes(ymin = l95_N, ymax = u95_N),
                  linetype = "44", fill = "cyan3", alpha = 0.3) +
      geom_line(aes(y = Sol_R)) +
      geom_line(aes(y = Sol_N)) +
      geom_line(aes(y = MED_R),
                linetype = "44", color = "purple") +
      geom_line(aes(y = MED_N),
                linetype = "44", color = "cyan4") +
      labs(title = title_txt,
           subtitle = paste0(paste("Overlap:", round(prob_auc*100, 3), "%"),
                            "\n",
                            paste("RMSE:", signif(p_df_rmse, 5))),
           y = "Concentration (mg/L)") +
      scale_x_continuous(breaks = seq(0,120, by = 12)) +
      theme_bw() +
      theme(plot.title = element_text(hjust = 0.5))
  }
  return(pl)
  
}

```


```{r parallel_sims}
# Parallelized simulation assessment
detectCores() # 16 cores, use 12
gc()

clust <- makeCluster(14L)
clusterEvalQ(clust, library("httk"))
clusterExport(clust, c("get_95CI_mc", "conc_fun_wsamples", "calc_overlap"))
clusterExport(clust, c("standard_parameterization", "standard_httk_preds",
                       "standard_httk_mc"))
clusterExport(clust, c("chem.physical_and_invitro.data"))
clusterExport(clust, c("ROUTE", "DOSE", "SAMPLES", "SPECIES", "TIMES", 
                       "VARPARS",
                       "CENSORPARS",
                       "HUMAN_CLINT_FUP"))

system.time(
  sim_bins <- unlist(parLapply(cl = clust, chems_available, assessment_fun))
)
stopCluster(clust)

table(sim_bins)
table(grepl("ND_SO_", sim_bins))
sum(table(sim_bins))
bindf <- data.frame(DTXSID = names(sim_bins), Bin = sim_bins,
                    CV_Clint = 0.1, CV_Funbound.plasma = 0.1, Dose = 25)
head(bindf)
rownames(bindf) <- NULL

saveRDS(bindf,
        paste0("data-raw/", SPECIES_TEXT, "_", ROUTE, INVITROUV_TEXT,
               "_simulation_bins.rds")
)

rm(clust)
rm(bindf)
gc()
```




```{r plot_all_chems}
# Parallelized simulation assessment
clust <- makeCluster(12L)
clusterEvalQ(clust, library("httk"))
clusterEvalQ(clust, library("ggplot2"))
clusterExport(clust, c("get_95CI_mc", "conc_fun_wsamples", "calc_overlap"))
clusterExport(clust, c("standard_parameterization", "standard_httk_preds",
                       "standard_httk_mc"))
clusterExport(clust, c("chem.physical_and_invitro.data"))
clusterExport(clust, c("ROUTE", "DOSE", "SAMPLES", "SPECIES", "TIMES", 
                       "VARPARS",
                       "CENSORPARS",
                       "HUMAN_CLINT_FUP"))

sim_pls <- parLapply(cl = clust, chems_available, plotting_fun)
stopCluster(clust)
length(seq_along(sim_pls))
gc()

pdf(file = paste0(Sys.getenv("FIG_DIR"), "RestNonRest_",SPECIES_TEXT,
                  ROUTE,"_Comparison_gasPBTK.pdf"),
    paper = "usr", bg = "white")
for (i in seq_along(sim_pls)) {
  print(sim_pls[[i]])
}
dev.off()
rm(sim_pls)
gc()

```


## Metabolism Landscape Tree

The goal is to find a tree structure that defines the above bins using the following data:  

- Lombardo:
  - Total Clearance (human)
  - Ion state at pH 7.4
- CvT/invivoPKfit:
  - Total Clearance (from best fit, mostly rat)
- HTTK:
  - Total Clearance (human & rat)
  - Funbound.plasma and Clint (human & rat)
  - Clearance fractions (liver, kidney, lung... human & rat, in PFAS branch)
  - Distinguishable or Non-Distinguishable bins (human & rat)
  
Then feature engineer the following:

- HTTK vs CvT clearances in Rat (over- or under-estimating)
- Differences in Human and Rat Clearance, Funbound.plasma, and Clint
- Closest Restrictive/Nonrestrictive based on invivoPKfit best fit.


While some missing data will be incorporated in this analysis,
this will not include data where Total Clearance is not known for 2 of 3 sources.


```{r}
lombardo <- readxl::read_xlsx(
  paste0(Sys.getenv("FIG_DIR"),
         "Lombardo2018-Supplemental_82966_revised_corrected.xlsx"),
  skip = 8) |> janitor::clean_names()

table(
  lombardo$cas_number %in% suppressWarnings(get_cheminfo("CAS", model = "gas_pbtk"))
)

```

What I want to do next is directly compare the _in vivo_ data to predictions. 

```{r cvt_object}
temp_data <- get_data(do_preprocess(pk(cvt)))
temp_data <- subset(temp_data, select = c("DTXSID",
                                          "Chemical_Name",
                                          "CASRN",
                                          "Species",
                                          "Media",
                                          "Route",
                                          "Dose",
                                          "Dose.Units",
                                          "N_Subjects",
                                          "Time",
                                          "Conc",
                                          "Conc_SD",
                                          "Conc.Units")) |>
  distinct()
```

```{r data-specific-parameterization}
# Each x is a grouped split of a data.frame
# Using a factor of DTXSID, Species, Media, Route, Dose
invivo_prediction <- function(
    x,
    vary.params = VARPARS,
    censored.params = CENSORPARS,
    force_human = HUMAN_CLINT_FUP
) {
  dtxsid <- unique(x[["DTXSID"]])
  species <- tools::toTitleCase(unique(x[['Species']]))
  media <- unique(x[['Media']])
  route <- unique(x[['Route']])
  dose <- unique(x[['Dose']])
  times <- unique(x[['Time']])/24 # Multiple values (in hours)
  
  invivo_preds <- conc_fun_wsamples(
    dtxsid = dtxsid,
    species = species,
    dose = dose,
    route = route,
    times = times,
    samples = 1000,
    force_human = force_human,
    vary.params = vary.params,
    censored.params = censored.params
  ) |> try()
  
  if (inherits(invivo_preds, "try-error")) return(NULL)
  
  # If measured media is blood need to divide CPLASMA results by Rblood2plasma
  if (media == "blood") {
    Rb2p <- standard_parameterization(
      dtxsid = dtxsid, 
      species = species,
      force_human = force_human
    )[['par_rest']][['Rblood2plasma']]
    
    browser()
    cols2convert <- apply(
      expand.grid(c("Sol", "l95", "MED", "u95"), c("_R", "_N")),
      MARGIN = 1,
      paste0, collapse = ""
      )
    
    invivo_preds <- invivo_preds |>
      dplyr::mutate(dplyr::across(dplyr::all_of(cols2convert), function(x) x / Rb2p))
  }
  
  cbind(
    data.frame(
    DTXSID = dtxsid,
    Species = tolower(species),
    Dose = dose,
    Route = route,
    Media = media
    ),
    as.data.frame(censored.params),
    as.data.frame(vary.params),
    invivo_preds
  )
}

```

```{r run_invivo_preds}
temp_data2 <- subset(temp_data, DTXSID %in% chems_available & Species == "rat")

split_factor <- with(
  temp_data2,
  factor(paste0(DTXSID, Species, Dose, Route, Media))
)
temp_lst <- split(temp_data2, split_factor)

# Run the cluster
clust <- makeCluster(12L)
clusterEvalQ(clust, library("httk"))
clusterEvalQ(clust, library("dplyr"))
clusterExport(clust, c("get_95CI_mc", "conc_fun_wsamples", "calc_overlap"))
clusterExport(clust, c("standard_parameterization", "standard_httk_preds",
                       "standard_httk_mc"))
clusterExport(clust, c("chem.physical_and_invitro.data"))
clusterExport(clust, c("VARPARS", "CENSORPARS", "HUMAN_CLINT_FUP"))

system.time(
  temp_lst <- parLapply(clust, temp_lst, invivo_prediction)
)
stopCluster(clust)

rm(clust)
gc()

temp_lst <- do.call(rbind, temp_lst)

temp_data3 <- left_join(temp_data2, temp_lst, relationship = "many-to-one")
saveRDS(temp_data3,
        paste0("data-raw/", SPECIES_TEXT, "_HTTK_preds_CvTdata.rds")
)
```


```{r bin-compare}
# Get the bins
bindf_rat <- readRDS("data-raw/Rat_oral_simulation_bins.rds") |>
  subset(select = c("DTXSID", "Bin"))
bindf_rat_parhuman <- readRDS("data-raw/Rat_parHuman_oral_simulation_bins.rds") |>
  subset(select = c("DTXSID", "Bin"))


afe_formula <- expression(
  paste("Average fold error: ", 10^{frac(1,n)*sum(log[10](frac(y, x)))})
)

temp_data3 |>
  filter(Sol_R > 0, Sol_N > 0) |>
  mutate(FE_R = log10(Sol_R / Conc), FE_N = log10(Sol_N / Conc)) |>
  group_by(DTXSID, Species, Media, Route, Dose) |>
  summarize(AFE_R = 10^(mean(FE_R)), AFE_N = 10^(mean(FE_N)), N_Obs = n()) |>
  ungroup() |>
  left_join(bindf_rat_parhuman) |>
  mutate(Bin = ifelse(Bin == "Distinguished", "Distinguishable", Bin)) |>
  arrange(DTXSID, Species, Media, Route, Dose) |>
  ggplot(aes(x = AFE_N, y = AFE_R)) +
  geom_point(aes(fill = log10(Dose)), shape = 21, color = "black", size = 1.2, alpha = 0.6) +
  geom_abline(slope = 1, intercept = 0) +
  geom_vline(xintercept = 1, linetype = "22", color = "grey20") +
  geom_hline(yintercept = 1, linetype = "22", color = "grey20") +
  facet_wrap(~Bin) +
  scale_fill_viridis_c() +
  labs(x = "Nonrestrictive Solution", y = "Restrictive Solution", 
       title = afe_formula) +
  scale_x_log10(labels = scales::label_log()) + scale_y_log10(labels = scales::label_log()) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        legend.position = "bottom",
        legend.title.position = "top")

ggsave(filename = paste0(Sys.getenv("FIG_DIR"), "AFE_CvT_HTTK_predictions_",
                         SPECIES_TEXT, INVITROUV_TEXT,
                         ".png"),
       width = 5, height = 5)

```

