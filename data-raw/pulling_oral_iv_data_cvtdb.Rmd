---
title: "Pulling oral and IV data from CvTdb"
author: "Caroline Ring, Gilberto Padilla Mercado"
date: "2023-09-29"
output: 
  html_document:
    toc: true
  pdf_document:
    toc: true
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  comment = NA,
  tidy.opts = list(width.cutoff = 75),
  tidy = TRUE
)
```

Load necessary packages: **DBI, dplyr, tidyr**

```{r}
library(DBI)
devtools::load_all() # So this loads the previous cvt object
library(dplyr)
library(tidyr)
library(readr)
```


# Connect to database

This section is largely taken from a `Querying CvTdb` vignette from Taylor Wall 
and a previous version of this vignette authored by Caroline Ring.  

For connection to CvTdb:

Connect to EPA VPN.

Set environment variables for the user name, password, host, and dbname that will be used to connect. Doing it this way allows us to not hardcode the password.

The following are some helper functions for the database connection.

```{r query_functions}
postgreSQL_connection <- function() {
  return(
    dbConnect(RPostgreSQL::PostgreSQL(),
      user = Sys.getenv("CVT_USER"),
      password = Sys.getenv("CVT_PASS"),
      host = Sys.getenv("CVT_HOST"),
      dbname = Sys.getenv("CVT_DB_NAME")
    )
  )
}

query_db <- function(query = NULL, schema) {
  if (is.null(query)) {
    return(cat("\nMust provide a query to send"))
  }
  con <- postgreSQL_connection()

  query_result <- tryCatch(
    return(dbGetQuery(con, query %>%
      gsub("FROM ", paste0("FROM ", schema, "."), .) %>%
      gsub("JOIN (?=\\w)", paste0("JOIN ", schema, "."), .,
        perl = TRUE
      ))),
    error = function(cond) {
      cat(paste0("\nError message: ", cond))
      return(NULL)
    },
    finally = {
      dbDisconnect(con)
    }
  )
  return(query_result)
}
```

```{r quick_message_funtion}
quick_message <- function(text = character()) {
  stopifnot(length(text) > 0)

  cli::cli_par()
  cli::cli_text(paste("{.strong [i]}  ", text[1], sep = "\t"))
  text <- text[-1]

  for (this_text in seq_along(text)) {
    cli::cli_li(text[this_text])
  }
  cli::cli_end()
}

quick_stats <- function(.data, old_version = FALSE) {
  stopifnot(is.data.frame(.data))

  cli::cli_h2("Statistics on the current data")
  message(paste0("Total number of data points: ", nrow(.data)))
  message("Unique Species and data counts:")
  print(table(.data$species))

  message(
    "Number of unique studies: ",
    length(unique(.data$fk_study_id))
  )
  message(
    "Number of unique series: ",
    length(unique(.data$fk_series_id))
  )

  if (old_version) {
    message(
      "Number of unique chemicals: ",
      length(unique(.data$analyte_dtxsid)),
      "\n"
    )
    chem_by_medium <- .data[c("conc_medium_normalized", "analyte_dtxsid")] %>%
      filter(!is.na(analyte_dtxsid)) %>%
      distinct()
    chem_by_curset <- .data[c("curation_set_tag", "analyte_dtxsid")] %>%
      filter(!is.na(analyte_dtxsid)) %>%
      distinct()
  } else {
    message(
      "Number of unique chemicals: ",
      length(unique(.data$analyzed_chem_dtxsid)),
      "\n"
    )
    chem_by_medium <- .data[c("conc_medium_normalized", "analyzed_chem_dtxsid")] %>%
      filter(!is.na(analyzed_chem_dtxsid)) %>%
      distinct()
    chem_by_curset <- .data[c("curation_set_tag", "analyzed_chem_dtxsid")] %>%
      filter(!is.na(analyzed_chem_dtxsid)) %>%
      distinct()
  }

  message(
    "Unique Dose units: ",
    toString(unique(.data$dose_level_units_original)),
    "\n"
  )
  if (all(is.na(.data$conc_units_normalized))) {
    message(
      "Unique Concentration units: ",
      toString(unique(.data$conc_units_original)),
      "\n"
    )
  } else {
    message(
      "Unique Concentration units: ",
      toString(unique(.data$conc_units_normalized)),
      "\n"
    )
  }
  message("Data by unique route of administration:")
  print(table(.data$administration_route_normalized))
  message("Data by medium collected:")
  print(table(.data$conc_medium_normalized))
  message("Data by curation set:")
  print(table(.data$curation_set_tag))
  message("\n\nUnique chemicals per medium:")
  print(table(chem_by_medium$conc_medium_normalized))
  message("Unique chemicals per curation set:")
  print(table(chem_by_curset$curation_set_tag))
}

chem_id_cols <- rlang::quos(
  fk_analyzed_chemical_id, fk_dosed_chemical_id,
  analyzed_chem_dtxsid, dosed_chem_dtxsid,
  analyzed_chem_name, dosed_chem_name,
  analyzed_chem_name_original, dosed_chem_name_original,
  analyzed_chem_name_secondary_original, 
  dosed_chem_name_secondary_original
)

unit_values_cols <- rlang::quos(
  conc_original, conc,
  conc_units_original, conc_units_normalized,
  conc_sd_original, conc_sd,
  loq, loq_units,
  dose_level_original, dose_level_normalized,
  dose_level_units_original, dose_volume_units,
  dose_volume, weight_kg
)

```


```{r diff_log_function}
# Now I want to write a quick function that will log relevant changes
# from previous 'cvt' objects
diff_log_cvt <- function(new_cvt,
                         key_id = "conc_time_id",
                         grp_ids = c(
                           "analyzed_chem_dtxsid",
                           "species"
                         ),
                         notes = character(0L)) {
  stopifnot(
    key_id %in% colnames(cvt),
    key_id %in% colnames(new_cvt),
    all(grp_ids %in% colnames(cvt)),
    all(grp_ids %in% colnames(new_cvt))
  )
  if (length(unique(new_cvt[[key_id]])) != NROW(new_cvt)) {
    stop("key_id is not not a column that uniquely identifies this data.")
  }

  # Prepare some vectors:
  grp_strings_new <- unique(do.call("paste", new_cvt[grp_ids]))
  grp_strings_old <- unique(do.call("paste", cvt[grp_ids]))

  msg_to_write <- paste0("\n\n======== ", round(Sys.time()))

  if (identical(new_cvt, cvt)) {
    msg_to_write <- paste(msg_to_write, "No changes.", sep = "\t")
    message(
      "There are no changes from previous `cvt` data.frame, ",
      "are you sure you want to save this?"
    )
  } else {
    msg_to_write <- paste(msg_to_write, "Changes detected.", sep = "\t")

    ### ---- Check key_id changes (usually conc_time_id)
    diff_row_add <- setdiff(new_cvt[[key_id]], cvt[[key_id]])
    diff_row_sub <- setdiff(cvt[[key_id]], new_cvt[[key_id]])
    diff_row_common <- intersect(cvt[[key_id]], new_cvt[[key_id]])
    # Nature of data changes:
    added_grps <- unique(
      do.call(
        "paste",
        new_cvt[which(new_cvt[[key_id]] %in% diff_row_add), grp_ids]
      )
    )
    removed_grps <- unique(
      do.call(
        "paste",
        cvt[which(cvt[[key_id]] %in% diff_row_sub), grp_ids]
      )
    )

    added_new_grps <- setdiff(added_grps, grp_strings_old)
    added_existing_grps <- intersect(added_grps, grp_strings_old)
    removed_new_grps <- setdiff(removed_grps, grp_strings_new)
    removed_existing_grps <- intersect(removed_grps, grp_strings_new)


    msg_to_write <- c(
      msg_to_write,
      paste("Rows added:", length(diff_row_add)),
      paste("Rows removed:", length(diff_row_sub))
    )

    limit_grp_output <- function(grp_vector) {
      if (length(grp_vector) > 0) {
        if (length(grp_vector) > 6) {
          grp_vector <- c(
            grp_vector[c(1, 2)],
            paste0(
              "... [",
              length(grp_vector) - 3,
              "] more!"
            ),
            grp_vector[c(length(grp_vector) - 1)]
          )
        }
        return(grp_vector)
      }
      msg_to_write <- c(
        msg_to_write,
        "New Groups added (not in previous data):",
        paste0("\t", limit_grp_output(added_new_grps)),
        "Groups with new observations (group present in previous data)",
        paste0("\t", limit_grp_output(added_existing_grps)),
        "Groups removed that no longer have data present:",
        paste0("\t", limit_grp_output(removed_new_grps)),
        "Groups removed that still have some data present:",
        paste0("\t", limit_grp_output(removed_existing_grps)),
        "-----------------------------------"
      )
    }

    ### -----Checking columns
    diff_col_add <- setdiff(names(new_cvt), names(cvt)) # Columns added in new_cvt
    diff_col_sub <- setdiff(names(cvt), names(new_cvt)) # Columns removed in new_cvt
    diff_col_common <- intersect(names(cvt), names(new_cvt))
    common_row_cvt <- cvt[cvt[[key_id]] %in% diff_row_common, ]

    common_row_cvt <- common_row_cvt[order(common_row_cvt[[key_id]]), ]

    common_row_new <- new_cvt[new_cvt[[key_id]] %in% diff_row_common, ]
    common_row_new <- common_row_new[order(common_row_new[[key_id]]), ]

    if (length(c(diff_col_add, diff_col_sub)) == 0) {
      msg_to_write <- c(
        msg_to_write,
        "No changes in column names."
      )
    } else if (length(diff_col_add) > 0 && length(diff_col_sub) > 0) {
      # Check renaming

      diff_columns <- function(x, y) {
        out_list <- character()
        for (ix in setdiff(names(x), key_id)) {
          for (iy in setdiff(names(y), key_id)) {
            tmp <- merge(x[c(key_id, ix)], y[c(key_id, iy)], by = key_id)
            if (identical(tmp[[2]], tmp[[3]])) {
              out_list <- c(out_list, paste0(ix, " -> ", iy))
            }
          }
        }
        return(out_list)
      }

      renamed_cols <- diff_columns(
        common_row_cvt[c(key_id, diff_col_sub)],
        common_row_new[c(key_id, diff_col_add)]
      )
      if (length(renamed_cols) > 0) {
        msg_to_write <- c(
          msg_to_write,
          "Renamed columns (non-exhaustive):",
          renamed_cols
        )
      } else {
        msg_to_write <- c(
          msg_to_write,
          "No renamed columns found."
        )
      }
    }
    if (length(diff_col_add) > 0) {
      msg_to_write <- c(
        msg_to_write,
        "--------------",
        "Columns added:",
        diff_col_add
      )
    }
    if (length(diff_col_sub) > 0) {
      msg_to_write <- c(
        msg_to_write,
        "______________",
        "Columns removed (from previous data):",
        diff_col_sub
      )
    }

    if ((NROW(
      setdiff(
        common_row_cvt[diff_col_common], common_row_new[diff_col_common]
      )
    ) > 0
    ) || (NROW(
      setdiff(
        common_row_new[diff_col_common], common_row_cvt[diff_col_common]
      )
    ) > 0
    )) {
      msg_to_write <- c(
        msg_to_write,
        "Data for same observation key_ids have changed."
      )

      # Which columns have different data?
      test_cols <- setdiff(diff_col_common, key_id)
      for (i in test_cols) {
        this_diff <- setdiff(
          common_row_new[c(key_id, i)],
          common_row_cvt[c(key_id, i)]
        )
        that_diff <- setdiff(
          common_row_cvt[c(key_id, i)],
          common_row_new[c(key_id, i)]
        )

        if (NROW(this_diff) > 0) {
          msg_to_write <- c(
            msg_to_write,
            paste0(c(i, "had", NROW(this_diff), "differences."), collapse = " ")
          )

          this_grp <- dplyr::distinct(common_row_new[
            common_row_new[[key_id]] %in% this_diff[[key_id]],
            grp_ids
          ])
          this_grp <- paste0(this_grp[1, 1:2], collapse = " ")

          # Print the differences (if below a certain number of rows)
          msg_to_write <- c(
            msg_to_write,
            paste0(
              "Example:",
              paste(this_grp, collapse = " "),
              collapse = " "
            ),
            paste0(c(i, "\t new:", this_diff[1, 2], "<--\t old:", that_diff[1, 2]),
              collapse = " "
            ), "\n"
          )
        }
      }
    }
    msg_to_write <- c(
      msg_to_write,
      notes,
      "================================\n"
    )
  }
  return(cat(msg_to_write, sep = "\n"))
}
```

# SQL Query

The SQL query result is built by left joining onto the `conc_time_values` table.
Additionally, because _invivoPKfit_ uses DTXSID as the standard chemical identifier,
it is important to repair some missing values for DTXSID. To do this, I 
make a separate query `SELECT distinct * FROM chemicals` and making the chemical
names to lowercase and by specifically taking the columns for name (now lowercase)
and DTXSID, I can see there are many instances of duplicated chemical entries
(which means they have separate `chemical.id` key values in this table). I then
"fill in" the DTXSID when they are missing and if any other instance of that
chemical name in the table has a DTXSID. I fill in DTXSIDs in the main
query result that I will be using using some joins with this repaired table.


```{r SQL_queries, warning=FALSE}
# Need to make this in a specified ordered
# First all IDs (so I can check them quickly)
# Note that this uses an ALIAS for each table which is later specified in
# the FROM and LEFT JOIN statements
series_chems <- paste0(
  "SELECT DISTINCT a.id, a.fk_analyzed_chemical_id, ",
  "b.analyzed_chem_dtxsid, b.analyzed_chem_name_original, ",
  "b.analyzed_chem_name_secondary_original, ",
  "b.analyzed_chem_casrn, b.analyzed_chem_name, ",
  "a.time_units_original, a.conc_units_original, ",
  "a.conc_units_normalized, a.loq, a.loq_units, ",
  "a.n_subjects_in_series, a.radiolabeled, a.fk_study_id, ",
  "a.qc_notes, a.qc_status, a.qc_flags, c.conc_medium_normalized ",
  "FROM series a ",
  "LEFT JOIN (SELECT id, dsstox_substance_id AS analyzed_chem_dtxsid, ",
  "chemical_name_original AS analyzed_chem_name_original, ",
  "chemical_name_secondary_original AS analyzed_chem_name_secondary_original, ",
  "dsstox_casrn as analyzed_chem_casrn, preferred_name AS analyzed_chem_name ",
  "FROM chemicals) AS b ON a.fk_analyzed_chemical_id = b.id ",
  "LEFT JOIN conc_medium_dict AS c ON a.fk_conc_medium_id = c.id"
)

study_docs <- paste0(
  "SELECT a.id, a.fk_extraction_document_id, a.fk_dosed_chemical_id, ",
  "b.pmid, b.doi, b.year, b.other_study_identifier, ",
  "b.url, b.extracted, b.curation_set_tag ",
  "FROM studies a ",
  "LEFT JOIN documents b ON a.fk_extraction_document_id = b.id"
)

audit_query <- query_db(
  paste0(
    "SELECT DISTINCT * FROM cvt_audit ",
    "WHERE fk_table_name IN ('documents', 'series', 'studies')"
  ),
  "cvt"
)
study_query <- query_db(study_docs, "cvt")
series_query <- query_db(series_chems, "cvt")
dtxsid_query <- query_db("SELECT DISTINCT * FROM chemicals", "cvt") %>%
  mutate(
    across(ends_with("_id"), as.character),
    across(contains("_name"), \(x) {
      stringr::str_to_lower(x) |>
        force_ascii_quotes() |>
        # trim whitespace around hyphens
        stringr::str_replace_all("\\s*-\\s*", "-") |>
        # comma-separate forms like 3'6 into 3',6
        stringr::str_replace_all("(?<=\\d)'(?=\\d)", "',") |>
        # fix some bracket cases
        stringr::str_replace_all("\\[3\\]h", "[3h]") |>
        stringr::str_replace_all("benzo\\[a\\]", "benzo(a)") |>
        # adds a space after square bracket separator
        stringr::str_replace_all("](?!\\s|-)", "] ")
    })
  )

select_chems <- subset(
  dtxsid_query,
  select = c(
    "id",
    "dsstox_substance_id",
    "dsstox_casrn",
    "preferred_name",
    "chemical_name_original",
    "chemical_name_secondary_original"
  )
)

# Surveying the non-equal chemical id landscape:
series_query |>
  inner_join(study_query, by = join_by(fk_study_id == id)) |>
  distinct(fk_analyzed_chemical_id, fk_dosed_chemical_id, curation_set_tag) |>
  count(fk_analyzed_chemical_id == fk_dosed_chemical_id)

unequal_chem_ids <- series_query |>
  inner_join(study_query, by = join_by(fk_study_id == id)) |>
  distinct(fk_analyzed_chemical_id, fk_dosed_chemical_id, curation_set_tag) |>
  filter(fk_analyzed_chemical_id != fk_dosed_chemical_id) |>
  left_join(
    rename_with(select_chems, ~ paste0("analyzed_", .x)),
    by = join_by(fk_analyzed_chemical_id == analyzed_id)
  ) |>
  left_join(
    rename_with(select_chems, ~ paste0("dosed_", .x)),
    by = join_by(fk_dosed_chemical_id == dosed_id)
  ) |>
  glimpse()

count(
  unequal_chem_ids,
  analyzed_dsstox_substance_id == dosed_dsstox_substance_id,
  analyzed_dsstox_casrn == dosed_dsstox_casrn,
  analyzed_preferred_name == dosed_preferred_name,
  analyzed_chemical_name_original == dosed_chemical_name_original,
  analyzed_chemical_name_secondary_original == dosed_chemical_name_secondary_original
) |>
  rename(
    "Equal DTXSID" = 1, "Equal CASRN" = 2, "Equal Preffered Name" = 3,
    "Equal Recorded Name" = 4, "Equal Secondary Recorded Name" = 5, "N" = 6
  )

# Are any names equal???
count(
  unequal_chem_ids,
  analyzed_dsstox_substance_id == dosed_dsstox_substance_id |
    analyzed_dsstox_casrn == dosed_dsstox_casrn |
    analyzed_preferred_name == dosed_preferred_name |
    analyzed_chemical_name_original == dosed_chemical_name_original |
    analyzed_chemical_name_secondary_original == dosed_chemical_name_secondary_original
) |>
  rename(
    "Any" = 1, "N" = 2
  ) |>
  mutate(
    Any = ifelse(Any %in% TRUE, "Some Identical", "None Identical")
  ) |>
  group_by(Any) |>
  summarize(N = sum(N)) |>
  pivot_wider(names_from = Any, values_from = N)

# Let's parse through with those "Some Identical" identifiers first
unequal_chem_ids |>
  filter(
    analyzed_dsstox_substance_id == dosed_dsstox_substance_id |
      analyzed_dsstox_casrn == dosed_dsstox_casrn |
      analyzed_preferred_name == dosed_preferred_name |
      analyzed_chemical_name_original == dosed_chemical_name_original |
      analyzed_chemical_name_secondary_original == dosed_chemical_name_secondary_original
  ) |>
  group_by(fk_analyzed_chemical_id, fk_dosed_chemical_id) |>
  summarize(
    same_dtxsid = if_else(
      analyzed_dsstox_substance_id == dosed_dsstox_substance_id,
      analyzed_dsstox_substance_id, NA_character_, missing = NA_character_
    ),
    same_casrn = if_else(
      analyzed_dsstox_casrn == dosed_dsstox_casrn,
      analyzed_dsstox_casrn, NA_character_, NA_character_
    ),
    same_preferred_name = if_else(
      analyzed_preferred_name == dosed_preferred_name,
      analyzed_preferred_name, NA_character_, NA_character_
    ),
    same_chem_name = if_else(
      analyzed_chemical_name_original == dosed_chemical_name_original,
      analyzed_chemical_name_original, NA_character_, NA_character_
    ),
    same_chem_name_secondary = if_else(
      analyzed_chemical_name_secondary_original == dosed_chemical_name_secondary_original,
      analyzed_chemical_name_secondary_original, NA_character_, NA_character_
    )
  ) |>
  rowwise() |>
  mutate(
    likely_same = sum(!is.na(c_across(starts_with("same_"))))
  ) |>
  ungroup() |>
  arrange(same_dtxsid, same_casrn, same_preferred_name, same_chem_name,
          same_chem_name_secondary) |>
  View("Similar IDs")
# There are two ways the identifiers may be duplicated,
# shown here between rows and columns


# There are a lot of duplicate DTXSIDs
query <- paste0(
  "SELECT distinct ",
  # Conc_Time_Values table fields
  "a.id, a.fk_series_id, a.time_original, a.time_hr, ",
  "a.conc_original, a.conc_sd_original, a.conc, a.conc_sd, ",

  # Series table fields
  "b.fk_analyzed_chemical_id, ",
  ## Chemical dictionary fields (analyzed chemical information)
  "l.analyzed_chem_dtxsid, l.analyzed_chem_name_original, ",
  "l.analyzed_chem_casrn, l.analyzed_chem_name, ",
  "l.analyzed_chem_name_secondary_original, ",
  "b.time_units_original, b.conc_units_original, ",
  "b.conc_units_normalized, b.loq, b.loq_units, ",
  "b.n_subjects_in_series, b.radiolabeled, b.fk_study_id, ",

  # Studies table fields
  "c.fk_dosed_chemical_id, ",
  ## Chemical dictionary fields (dosed chemical information)
  "k.dosed_chem_dtxsid, k.dosed_chem_name_original, ",
  "k.dosed_chem_casrn, k.dosed_chem_name, ",
  "k.dosed_chem_name_secondary_original, ",
  "c.dose_volume, c.dose_volume_units, c.dose_vehicle, ",
  "c.dose_duration, c.dose_duration_units, ",
  ## dose_frequency dictionary fields
  "j.dose_frequency_original, j.dose_frequency_normalized, ",
  "c.fasting_period, ",
  "c.dose_level_normalized, c.dose_level_original, ",
  "c.dose_level_units_original, c.dose_level_units_normalized, ",
  ## conc_medium dictionary fields
  "i.conc_medium_original, i.conc_medium_normalized, ",
  ## administration_route dictionary fields
  "h.administration_route_original, h.administration_route_normalized, ",
  ## administration_method dictionary fields
  # "g.administration_method_original, g.administration_method_normalized, ",
  ## administration_form dictionary fields
  # "f.administration_form_original, f.administration_form_normalized, ",

  # Subjects table fields
  "b.fk_subject_id, d.weight_kg, d.species, d.sex, d.age, d.age_units, d.age_category, ",
  # Documents table fields
  "c.fk_extraction_document_id, e.pmid, e.year, e.other_study_identifier, ",
  "e.url, e.doi, e.extracted, e.curation_set_tag ",

  # Main Table
  "FROM conc_time_values a ",

  # Join with series table by series ID
  "LEFT JOIN series b ON a.fk_series_id = b.id ",

  # Join to studies table by study ID
  "LEFT JOIN studies c ON b.fk_study_id = c.id ",

  # Join to subjects table by subject ID
  "LEFT JOIN subjects d ON b.fk_subject_id = d.id ",

  # Join to documents table by extraction document ID
  "LEFT JOIN documents e ON c.fk_extraction_document_id = e.id ",

  # # Join to dictionary tables
  # "LEFT JOIN administration_form_dict f ON c.fk_administration_form_id = f.id ",
  # "LEFT JOIN administration_method_dict g ON c.fk_administration_method_id = g.id ",
  "LEFT JOIN administration_route_dict h ON c.fk_administration_route_id = h.id ",
  "LEFT JOIN conc_medium_dict i ON b.fk_conc_medium_id = i.id ",
  "LEFT JOIN dose_frequency_dict j ON c.fk_dose_frequency_id = j.id ",

  # Rename chemical fields for dosed vs. analyzed chemical record foreign keys
  "LEFT JOIN (SELECT id, dsstox_substance_id AS dosed_chem_dtxsid, ",
  "chemical_name_original AS dosed_chem_name_original, ",
  "chemical_name_secondary_original AS dosed_chem_name_secondary_original, ",
  "dsstox_casrn AS dosed_chem_casrn, preferred_name AS dosed_chem_name ",
  "FROM chemicals) AS k ON c.fk_dosed_chemical_id = k.id ",
  "LEFT JOIN (SELECT id, dsstox_substance_id AS analyzed_chem_dtxsid, ",
  "chemical_name_original AS analyzed_chem_name_original, ",
  "chemical_name_secondary_original AS analyzed_chem_name_secondary_original, ",
  "dsstox_casrn AS analyzed_chem_casrn, preferred_name AS analyzed_chem_name ",
  "FROM chemicals) AS l ON b.fk_analyzed_chemical_id = l.id ",

  # Filtering steps
  "WHERE h.administration_route_normalized IN ('iv', 'oral') AND ",
  "(i.conc_medium_normalized IN ('blood', 'plasma') OR ",
  "i.conc_medium_original IN ('blood', 'plasma')) AND ",
  "(j.dose_frequency_normalized IN ('Once') OR e.curation_set_tag IN ('CVT_Showa'))"
)

sql_query <- query_db(query = query, schema = "cvt")

# Need to change the column name for this
names(sql_query)[1] <- "conc_time_id"

cvtdb_original <- sql_query
save(cvtdb_original, file = "data/cvtdb_original.rda", compress = "bzip2")
```

```{r harmonizing}
load("data/cvtdb_original.rda")
sql_query <- cvtdb_original
rm(cvtdb_original)

# Harmonize values for easier analysis
cvt_df <- sql_query %>%
  mutate(
    # Note that sometimes fk_test_chemical_id is NA
    across(all_of(c(
      "time_original",
      "time_hr",
      "conc_original",
      "conc_sd_original",
      "conc",
      "conc_sd",
      "dose_level_original",
      "dose_level_normalized",
      "loq"
    )), as.numeric),
    # conc, conc_sd_original, and conc_original
    # have NA/NE/ND values that are coerced to NAs
    year = as.character(year),
    species = tolower(species),
    sex = tolower(sex),
    across(contains("chem_name"), \(x) {
      stringr::str_to_lower(x) |>
        force_ascii_quotes() |>
        # trim whitespace around hyphens
        stringr::str_replace_all("\\s*-\\s*", "-") |>
        # comma-separate forms like 3'6 into 3',6
        stringr::str_replace_all("(?<=\\d)'(?=\\d)", "',") |>
        # fix some bracket cases
        stringr::str_replace_all("\\[3\\]h", "[3h]") |>
        stringr::str_replace_all("\\[a\\]pyr", "(a)pyr") |>
        stringr::str_remove_all(" \\(aids\\)$") |>
        # adds a space after square bracket separator
        stringr::str_replace_all("](?!\\s|-)", "] ")
    }),
    dose_volume_units = ifelse(
      dose_volume_units %in% c("NR", "ND"),
      NA_character_,
      gsub(" / ", "/", gsub("ml", "mL", dose_volume_units))
    ),
    dose_volume = signif(as.numeric(dose_volume), digits = 7),
    dose_duration_units = trimws(dose_duration_units),
    dose_duration = as.numeric(stringr::str_extract(dose_duration,
      pattern = "^\\d+"
    )),
    dose_frequency_normalized = "Once", # Showa is not annotated
    radiolabeled = ifelse(is.na(radiolabeled), FALSE, as.logical(radiolabeled)),
    # for n_subject ranges, take integer value of median
    # otherwise pull number or NA
    n_subjects_normalized = case_when(
      n_subjects_in_series %in% "NR" ~ NA_real_,
      grepl("-", n_subjects_in_series) ~ floor(mean(
        as.numeric(unlist(strsplit(n_subjects_in_series, split = "-"))),
        na.rm = TRUE
      )),
      .default = as.numeric(
        stringr::str_extract(n_subjects_in_series, pattern = "\\d+")
      )
    )
  )
```

## Some data malformations

There are some duplications in chemical entries such that not all unique chemical ids
represent a unique DTXSID, but rather a unique original name entry.
To fix this, when DTXSIDs for dosed and analyzed chemicals match, I will
be setting `fk_dosed_chemical_id` to `fk_analyzed_chemical_id`.

Note that we can "de-duplicate" these in two ways. Take for instance:

|analyzed_chem_id|dosed_chem_id|analyzed_dtxsid|dosed_dtxsid  |
|---------------:|:------------|--------------:|:-------------|
| 893            | 892         | DTXSID0021383 | DTXSID0021383|
| 929            | 893         | DTXSID0021383 | DTXSID0021383|

This is duplicated across rows and between rows! Ideally, we would take the
"most complete" record if we are convinced that these are the same chemical.

There is also some radiolabeling experiments that aren't described as such.
We can use `stringr::str_detect(x,"(13|14)c")` to recode `radiolabeled = TRUE`
for these.

Then we should address the fact that the `invivoPKfit_2.0.0` version of the `cvt`
object has 228 chemicals, while the recent query only has 145. This is a
difference of 83.

By hand, I can add back the DTXSIDs for about 15 chemicals. Some of these will
be ChEMBLIDs actually.


```{r malformed_data}
# First quick check to see if any chemical_ids are NA
# Should be FALSE for both of these!
any(is.na(cvt_df$fk_analyzed_chemical_id))
any(is.na(cvt_df$fk_dosed_chemical_id))

cli::cli_inform(
  "{length(unique(cvt_df$analyzed_chem_dtxsid))} unique analyzed_dtxsids"
)

cli::cli_inform(
  "{length(unique(cvt_df$dosed_chem_dtxsid))} unique dosed dtxsids"
)

# Fix Radiolabeled ones!
cvt_df %>%
  distinct(analyzed_chem_name_original, dosed_chem_name_original, radiolabeled) %>%
  filter(!radiolabeled) %>%
  filter(stringr::str_detect(dosed_chem_name_original, "((13|14)c|3h)"))
cvt_df %>%
  distinct(analyzed_chem_name_original, dosed_chem_name_original, radiolabeled) %>%
  filter(!radiolabeled) %>%
  filter(stringr::str_detect(analyzed_chem_name_original, "((13|14)c|3h)"))

cvt_df <- cvt_df %>%
  mutate(
    radiolabeled = ifelse(
      stringr::str_detect(dosed_chem_name_original, "((13|14)c|3h)") |
        stringr::str_detect(analyzed_chem_name_original, "((13|14)c|3h)"),
      TRUE,
      radiolabeled
    )
  )
# There is a distinct challenge when handling radiolabelled data but these will be
# filtered out later for our purposes.
# Pre-emptive filtering to cut down workload
cvt_df <- filter(cvt_df, !(radiolabeled %in% TRUE))

cvt_df$analyzed_chem_name_original[
  grepl("\\[\\w\\]", cvt_df$analyzed_chem_name_original)
] |> unique()

cvt_df$dosed_chem_name_original[
  grepl("\\[\\w\\]", cvt_df$dosed_chem_name_original)
] |> unique()

cvt_df |> 
  distinct(!!!chem_id_cols) |> 
  count(is.na(analyzed_chem_dtxsid), is.na(dosed_chem_dtxsid))
# Most have both dosed and chemical dtxsid
# Are the 'NA' values for analyzed_chem_dtxsid that have dosed_chem_dtxsid the same?

cvt_df <- cvt_df |>
  mutate(
    # fix misspellings
    analyzed_chem_name_original = str_replace_lst(
      analyzed_chem_name_original,
      c(
        "paracetmol" = "paracetamol",
        "deacetyl diltiazem" = "desacetyl diltaiazem",
        "deacetyl n-monodesmethyl diltiazem" = "desacetyl n-monodesmethyl diltiazem",
        "2,2',4,4',5,5'-hexachlorobiphenyl" = "2,4,5,2',4',5'-hexachlorobiphenyl",
        "valproate \\(vpa\\)" = "valproic acid",
        "clotiapine" = "clothiapine"
      )
    ),
    dosed_chem_name_original = str_replace_lst(
      dosed_chem_name_original,
      c(
        "paracetmol" = "paracetamol",
        "deacetyl diltiazem" = "desacetyl diltaiazem",
        "deacetyl n-monodesmethyl diltiazem" = "desacetyl n-monodesmethyl diltiazem",
        "2,2',4,4',5,5'-hexachlorobiphenyl" = "2,4,5,2',4',5'-hexachlorobiphenyl",
        "clotiapine" = "clothiapine"
      )
    ),
    # Missing DTXSIDs I found
    dosed_chem_dtxsid = case_match_lst(
      dosed_chem_name_original,
      c(
        "4,4'-sulfonylbisphenol-d8" = "DTXSID3022409",
        "(+-)-metoprolol tartrate" = "DTXSID9037248",
        "antipyrene" = "DTXSID6021117",
        "3'-azido-3'-deoxythymidine" = "DTXSID8020127",
        "2,4,5,2',4',5'-hexachlorobiphenyl" = "DTXSID2032180"
      ),
      dosed_chem_dtxsid
    ),
    analyzed_chem_dtxsid = case_match_lst(
      analyzed_chem_name_original,
      c(
        "fluorotelomer acid 7+3" = "DTXSID20874028",
        "valproic acid" = "DTXSID6023733",
        "s-(-)-metoprolol" = "DTXSID60230861",
        "r-(+)-metoprolol" = "DTXSID20230862",
        "paracetamol" = "DTXSID2020006"
      ),
      analyzed_chem_dtxsid
    ),
    # check name matches
    analyzed_chem_dtxsid = ifelse(
      is.na(analyzed_chem_dtxsid) &
        analyzed_chem_name_original == dosed_chem_name_original,
      dosed_chem_dtxsid,
      analyzed_chem_dtxsid
    )
  )

quick_stats(cvt_df)
# quick_stats(cvt_2.0.0, old_version = FALSE)
# Note unique chemical counts

cvt_df |>
  distinct(!!!chem_id_cols) |> 
  filter(is.na(analyzed_chem_dtxsid)) |>
  View("ID-less")
# Anything without an ID for analyzed_chemical is likely a metabolite/control of sorts
# So... I filter it out.
cvt_df <- cvt_df |> 
  filter(!is.na(analyzed_chem_dtxsid))


quick_stats(cvt_df)


# Now we need to pre-emptively address the chemicals that have different
# IDs but are actually the same chemical or represent the same chemical during the experiment
# This includes primarily: SALTS and ENANTIOMERS
cvt_df %>%
  filter(
    fk_analyzed_chemical_id != fk_dosed_chemical_id,
    analyzed_chem_dtxsid != dosed_chem_dtxsid
  ) %>%
  distinct(
    analyzed_chem_name_original, dosed_chem_name_original,
    fk_analyzed_chemical_id, fk_dosed_chemical_id,
    analyzed_chem_dtxsid, dosed_chem_dtxsid
  ) %>%
  arrange(analyzed_chem_name_original) %>%
  # head()
View()

# The other issue with salts is sometimes they will appear in analyzed chemical names!
# Compose regular expressions looking for possible salts.
mcations <- paste(
  c("(hydrogen", "lithium", "sodium", "potassium", "rubidium", "cesium",
    "silver", "beryllium", "magnesium", "strontium", "barium", "radium",
    "zinc", "calcium", "aluminum)"),
  collapse = "|"
)
manions <-  paste(
  c("(hydride", "fluoride", "chloride", "bromide", "iodide", "oxide",
    "sulfide", "selenide", "telluride", "nitride", "phosphiide",
    "arsenide)"),
  collapse = "|"
)

pa_ions <- paste(
  c(
    "(ammonium", "nitrate", "nitrite", "chromate", "dichromate", "cyanide",
    "permanganate", "hydroxide", "peroxide", " amide", "carbonate", "sulfate",
    "sulfite", "oxalate", "phosphate", "phosphite", "thiosulfate",
    "arsenate", "selenate", "silicate", "tartrate", "perchlorate", "acetate",
    "chlorate", "chlorite", "hypochlorite", "periodate", "iodate", "hypoiodite",
    "bromate", "hypobromite", "binoxolate", "borate", "hydrochloride", "thiocyanate)"
  ),
  collapse = "|"
)

cvt_df |>
  distinct(!!!chem_id_cols) |>
  filter(
    stringr::str_detect(analyzed_chem_name_original, pattern = mcations) |
      stringr::str_detect(analyzed_chem_name_original, pattern = manions) |
      stringr::str_detect(analyzed_chem_name_original, pattern = pa_ions) |
      stringr::str_detect(analyzed_chem_name, pattern = mcations) |
      stringr::str_detect(analyzed_chem_name, pattern = manions) |
      stringr::str_detect(analyzed_chem_name, pattern = pa_ions) |
      stringr::str_detect(dosed_chem_name_original, pattern = mcations) |
      stringr::str_detect(dosed_chem_name_original, pattern = manions) |
      stringr::str_detect(dosed_chem_name_original, pattern = pa_ions) |
      stringr::str_detect(dosed_chem_name, pattern = mcations) |
      stringr::str_detect(dosed_chem_name, pattern = manions) |
      stringr::str_detect(dosed_chem_name, pattern = pa_ions)
  ) |>
  View("Potential salt errors")

# Method: To make DTXSID == DTXSID, salt DTXSIDs will be replaced with
# non-salt DTXSIDs.
cvt_df <- cvt_df |> 
  mutate(
    analyzed_chem_dtxsid = case_match_lst(
      analyzed_chem_name,
      c(
        "methadone hydrochloride" = "DTXSID7023273",
        "ammonium perfluorooctanoate" = "DTXSID40892486",
        "sodium nitrite" = "DTXSID5024219",
        "potassium perfluorobutanesulfonate" = "DTXSID5030030", # acid is more stable
        "potassium perfluorohexanesulfonate" = "DTXSID80873012"
      ),
      analyzed_chem_dtxsid
    ),
    dosed_chem_dtxsid = case_match_lst(
      analyzed_chem_name,
      c(
        "methadone hydrochloride" = "DTXSID7023273",
        "ammonium perfluorooctanoate" = "DTXSID40892486",
        "sodium nitrite" = "DTXSID5024219",
        "potassium perfluorobutanesulfonate" = "DTXSID5030030", # acid is more stable
        "potassium perfluorohexanesulfonate" = "DTXSID80873012",
        "bosentan" = "DTXSID7046627",
        "hexobarbital" = "DTXSID9023122",
        "quinidine" = "DTXSID4023549"
      ),
      dosed_chem_dtxsid
    ),
    dosed_chem_dtxsid = case_match_lst(
      dosed_chem_name,
      c(
        "imipramine hydrochloride" = "DTXSID1043881",
        "ondansetron hydrochloride dihydrate" = "DTXSID8023393",
        "thiopental sodium" = "DTXSID1023653",
        "phenobarbital" = "DTXSID5021122",
        "phenobarbital sodium" = "DTXSID5021122",
        "potassium perfluorohexanesulfonate" = "DTXSID80873012",
        "tamoxifen citrate" = "DTXSID1034187",
        "sodium nitrite" = "DTXSID5024219"
      ),
      dosed_chem_dtxsid
    ),
    analyzed_chem_dtxsid = case_match_lst(
      analyzed_chem_name_original,
      c(
        "formetanate hydrochloride" = "DTXSID9041990",
        "propamocarb hydrochloride" = "DTXSID1040295",
        "pyrithiobac sodium" = "DTXSID3037703",
        "tamoxifen citrate" = "DTXSID1034187"
      ),
      analyzed_chem_dtxsid
    ),
    dosed_chem_dtxsid = case_match_lst(
      analyzed_chem_name_original,
      c(
        "formetanate hydrochloride" = "DTXSID9041990",
        "propamocarb hydrochloride" = "DTXSID1040295",
        "pyrithiobac sodium" = "DTXSID3037703",
        "valproic acid" = "DTXSID6023733",
        # add the enantiomers of metoprolol here
        "r-(+)-metoprolol" = "DTXSID20230862",
        "s-(-)-metoprolol" = "DTXSID60230861"
      ),
      dosed_chem_dtxsid
    )
  ) # This is imperfect but will do.

cvt_df |> 
  distinct(analyzed_chem_dtxsid, dosed_chem_dtxsid) |> 
  count(analyzed_chem_dtxsid == dosed_chem_dtxsid)
cvt_df |>
  distinct(!!!chem_id_cols) |> 
  filter(analyzed_chem_dtxsid != dosed_chem_dtxsid) |> 
  View()

## Now that we've added some missing DTXSIDs, redo the chemical id
cvt_df <- cvt_df %>%
  rowwise() %>%
  mutate(fk_dosed_chemical_id = ifelse(
    identical(analyzed_chem_dtxsid, dosed_chem_dtxsid),
    fk_analyzed_chemical_id,
    fk_dosed_chemical_id
  )) %>%
  ungroup()

any(is.na(cvt_df$fk_analyzed_chemical_id))
any(is.na(cvt_df$fk_dosed_chemical_id))

quick_stats(cvt_df)
```


# Validating data

This step in the loading process allows us to correct some mis-annotations in the
data, without directly changing CvTdb (the review process there is more rigorous).
Some of these changes will be sent as a ticket item for the CvTdb team.
Other times, the annotation is correct, it's just that units need to be standardized
for `invivoPKfit` specifically.  

There are some procedures needed to be taken to standardized some of this data
such that dose units are all in mg/kg of bodyweight and concentration units are in
ug/L.

## Preliminary Filtering

I begin with a couple of filtering steps:  

+ Exclude data without any concentration value  
+ Exclude data with only one observation per *study_id*

```{r preliminary_filtering}
cvt_df <- cvt_df %>%
  filter(
    !is.na(analyzed_chem_dtxsid),
    (fk_analyzed_chemical_id == fk_dosed_chemical_id)
  ) %>%
  distinct()

quick_message(text = c(
  "Filtering out:",
  "Missing {.code analyzed_chem_dtxsid}",
  "Data where the analyzed chemicals and dosed chemicals are different"
))


quick_stats(cvt_df)


# Filtering out non-circulation mediums (these are retained in cvtdb_original)
cvt_df <- cvt_df %>%
  filter(conc_medium_normalized %in% c("blood", "plasma"))

quick_message(text = c(
  "Filtering out:",
  "Non-plasma/blood medium collected."
))

# Filter out where all values in experiment are missing values/below LOQ
# Also filter out observations where
cvt_df <- cvt_df %>%
  mutate(
    conc = ifelse(conc < 0, NA_real_, conc),
    conc_original = ifelse(conc_original < 0, NA_real_, conc_original)
  ) %>%
  group_by(
    analyzed_chem_dtxsid, species, fk_extraction_document_id,
    administration_route_normalized, conc_medium_normalized
  ) %>%
  filter(
    !(if_all(conc, is.na) & if_all(conc_original, is.na))
  ) %>%
  ungroup() %>%
  distinct()


quick_message(text = c(
  "Filtering out:",
  "Experiments missing concentration values altogether."
))

quick_stats(cvt_df)


# Need to see all the conc, conc_sd, dose, loq (original, values and units)
# Dose Units: Need mg/kg... = ug/mg = ng/ug, and kg = L
# Conc Units: Need mg/L... = ug/mL = ng/uL = pg/nL, and kg = L, g = mL
cvt_df <- cvt_df %>% mutate(
  conc_units_original = stringr::str_replace(
    conc_units_original, 
    pattern = "l$",
    replacement = "L"
  ),
  conc_units_original = stringr::str_replace(
    conc_units_original, 
    pattern = "\u00B5",
    replacement = "u"
  ),
  conc_units_normalized = stringr::str_replace(
    conc_units_normalized, 
    pattern = "l$",
    replacement = "L"
  ),
  loq_units = stringr::str_replace(loq_units, "l$", "L"),
  invivPK_dose_level_units = "mg/kg",
  invivPK_conc_units = "ug/mL"
)

# Filtering out observations with no concentration information
cvt_df <- cvt_df |> 
  filter(!(is.na(conc_original) & is.na(conc)))

```

For the majority of compounds with a missing `conc` value, it is usually a 
factor of converting `conc_units_original` to the standard `conc_units_normalized`.

While I leave most of this curation work to the CvTdb team which have been working
on this data since 2020 at least, I will try to wade through the data for
the following 5 chemicals with large amounts of data that is missing.

1. _tetralin/DTXSID1026118_: has `conc_units_original` in `ug/g` of plasma concentration.
Blood plasma has a density of approximately `1.025 g/mL` which means that the values
for `conc_original` and `loq` can be multiplied by this value to give the standard
`ug/mL`.

2. _PCB 136/DTXSID6073499_: has some `conc_units_original` in `ng/g` of whole blood
concentration. Whole blood has a density of approximately `1.05 g/mL` which means
we can multiply the concentrations by $1.05\frac{g}{mL}\times 10^{-3}\frac{\mu g}{ng}$.
For simplicity, I will discard the observations where `conc_units_original` is
given in `molar percentage`.

3. _PFOA/DTXSID40892486_: has some `conc_units_original` in `ug/g` of plasma.
I will apply the same formula as #1 above.

4. _propyzamide/DTXSID2020420_: this, and all chemicals in `pmid == 29385628`
have concentration over time values of `mg/kg`, but these are actually the
`ug/mL`. This is apparent in the Supplementary Table 1 of this paper. The `loq`
values are carefully calibrated, but should all be in `ng/mL` units.

5. _carbon disulfide/DTXSID6023947_: similar to #2 the `conc_units_original` is
in `ug/g` of whole blood, which means we can simply multiply `conc_original`
by `1.05 g/mL` to supply `conc`.

In general, if we have missing `conc` values, we are only interested in those
that have a mass value (i.e. kg, g, ug) in the denominator, so I will begin
by filtering out all other observations.

```{r}
# Densities in units: g/ml
WB_DENSITY = 1.05 
PL_DENSITY = 1.025

# This removes around 100 observations!
cvt_df <- cvt_df |>
  filter(!is.na(conc) | stringr::str_detect(conc_units_original, "g$"))


cvt_df <- cvt_df |>
  mutate(
    conc = case_when(
      # Carry over values when pmid == 29385628
      is.na(conc) & 
        pmid == 29385628L & 
        conc_units_original == "mg/kg" ~ conc_original,
      is.na(conc) &
        conc_medium_normalized == "plasma" &
        conc_units_original == "ug/g" ~ conc_original * PL_DENSITY,
      is.na(conc) &
        conc_medium_normalized == "blood" &
        conc_units_original == "ug/g" ~ conc_original * WB_DENSITY,
      is.na(conc) &
        conc_medium_normalized == "blood" &
        conc_units_original == "ng/g" ~ conc_original * WB_DENSITY * 1E-3,
      is.na(conc) &
        conc_medium_normalized == "plasma" &
        conc_units_original == "ng/g" ~ conc_original * PL_DENSITY * 1E-3,
      .default = conc
    )
  )

quick_stats(cvt_df)

# When LOQ values are present, the units are always specified
# There is one case that is at first glance not an easy conversion, nmol/mL,
# but TAME has a mass of 102.104465 g/mol. LOQ value in ug/mL is approximately the
# same and we will treat it as such
# There is another case where loq_units is recorded as "ng". I will treat this as "ng/mL"

cvt_df <- cvt_df |> 
  mutate(
    loq = case_when(
      loq_units %in% c("ug/L", "ng/mL", "ng") ~ loq * 1E-3,
      loq_units == "pg/mL" ~ loq * 1E-6,
      loq_units == "ng/g" & conc_medium_normalized == "blood" ~ loq * WB_DENSITY * 1E-3,
      loq_units == "ug/g" & conc_medium_normalized == "blood" ~ loq * WB_DENSITY,
      loq_units == "ug/g" & conc_medium_normalized == "plasma" ~ loq * PL_DENSITY,
      .default = loq
    ),
    loq_units = "ng/uL"
  )

quick_stats(cvt_df)

```

Per the CvTdb 2.0.0 release notes, Dose is normalized to `mg/kg BW`.
However, there are some with missing values, representing 180 observations across
3 chemicals (by DTXSIDs): quinidine, clothiapine, and padsevonil. I will simply 
exclude these in this case.

```{r handling_dose}
cvt_df <- cvt_df |> filter(dose_level_units_normalized == "mg/kg BW")

quick_stats(cvt_df)
```


```{r plot_by_dtxsid}
cvt_df %>%
  ggplot(aes(
    x = time_hr, y = conc, group = analyzed_chem_dtxsid,
    color = analyzed_chem_dtxsid
  )) +
  geom_point() +
  geom_smooth(se = FALSE) +
  theme_bw() +
  scale_y_log10() +
  theme(legend.position = "none")
```


```{r final_checks}
cvt_df %>%
  count(
    is.na(dose_level_normalized),
    is.na(dose_level_original)
  ) %>%
  glimpse()

cvt_df %>%
  count(is.na(conc_sd) & n_subjects_normalized > 1)

cvt_df %>%
  count(is.na(n_subjects_normalized))

cvt_df <- cvt_df |> select(!starts_with("invivPK_"))
cvt_df <- cvt_df |> filter(time_hr >= 0)

```

### Changes to mapping!
We now use `conc`, `conc_units_normalized`, `loq`, `loq_units`,
`dose_level_units_normalized`, and `dose_level_normalized` directly.

Save the pulled CVT data with the edits/normalizations, and also save the current date.

```{r saving_data, include=FALSE, eval=FALSE}
cvt_date <- Sys.Date()

cvt <- cvt_df
save(cvt, file = "data/cvt.rda", compress = "bzip2")
save(cvt_date, file = "data/cvt_date.rda")
```

# QSAR Bakeoff Run

```{r running}
my_pk <- pk(
  cvt,
  mapping = ggplot2::aes(
    Chemical = analyzed_chem_dtxsid,
    Chemical_Name = analyzed_chem_name_original,
    DTXSID = analyzed_chem_dtxsid,
    CASRN = analyzed_chem_casrn,
    Species = species,
    Reference = fk_extraction_document_id,
    Media = conc_medium_normalized,
    Route = administration_route_normalized,
    Dose = dose_level_normalized,
    Dose.Units = "mg/kg",
    Subject_ID = fk_subject_id,
    Series_ID = fk_series_id,
    Study_ID = fk_study_id,
    ConcTime_ID = conc_time_id,
    N_Subjects = n_subjects_normalized,
    Weight = weight_kg,
    Weight.Units = "kg",
    Time = time_hr,
    Time.Units = "hours",
    Value = conc,
    Value.Units = "mg/L",
    Value_SD = conc_sd,
    LOQ = loq
  )
)

my_pk <- my_pk +
  stat_error_model(Chemical, Species) +
  settings_optimx(method = "bobyqa") +
  facet_data(Chemical, Species) +
  settings_preprocess(
    keep_data_original = TRUE,
    suppress.messages = TRUE
  ) +
  scale_conc(dose_norm = TRUE, log10_trans = TRUE)

my_pk <- do_preprocess(my_pk)
apply(my_pk$data, 2, \(x) {
  any(is.na(x))
})

my_pk <- do_data_info(my_pk)
my_pk <- do_prefit(my_pk)

mirai::daemons(8)
mirai::everywhere(devtools::load_all())
my_pk <- do_fit(my_pk, async = TRUE)
mirai::daemons(0)


fit_pl <- plot(my_pk, use_scale_conc = FALSE)

fit_pl %>%
  filter(Chemical %in% "DTXSID1021116", Species %in% "human") %>%
  pull(final_plot) %>%
  .[[1]]
fit_pl %>%
  filter(Chemical %in% "DTXSID9025617", Species %in% "mouse") %>%
  pull(final_plot) %>%
  .[[1]]
fit_pl %>%
  filter(Chemical %in% "DTXSID9025617", Species %in% "rat") %>%
  pull(final_plot) %>%
  .[[1]]
fit_pl %>%
  filter(Chemical %in% "DTXSID2021781", Species %in% "mouse") %>%
  pull(final_plot) %>%
  .[[1]]
fit_pl %>%
  filter(Chemical %in% "DTXSID1034187") %>% # Tamoxifen sanity check
  pull(final_plot) %>%
  .[[1]]

fit_pl %>%
  filter(Chemical %in% "DTXSID1043881") %>% # Imipramine sanity check
  pull(final_plot) %>%
  .[[1]]
fit_pl %>%
  filter(Chemical %in% "DTXSID1023653") %>% # Thiopental sanity check
  pull(final_plot) %>%
  .[[1]]
fit_pl %>%
  filter(Chemical %in% "DTXSID5021122") %>% # Phenobarbital sanity check
  pull(final_plot) %>%
  .[[1]]
fit_pl %>%
  filter(Chemical %in% "DTXSID80873012") %>% # PFHS sanity check
  pull(final_plot) %>%
  .[[1]]
fit_pl %>%
  filter(Chemical %in% "DTXSID20230862") %>% # Metoprolol sanity check
  pull(final_plot) %>%
  .[[1]]
fit_pl %>%
  filter(Chemical %in% "DTXSID60230861") %>% # Metoprolol sanity check
  pull(final_plot) %>%
  .[[1]]
fit_pl %>%
  filter(Chemical %in% "DTXSID8031865") %>% # Metoprolol sanity check
  pull(final_plot) %>%
  .[[1]]


get_winning_model(my_pk) %>% filter(Chemical %in% "DTXSID1034187")
get_fit(my_pk) |>
  distinct(Chemical, Species, model, convergence) |> 
  count(model, convergence)

eval_tkstats(my_pk) |> glimpse(80)
eval_tkstats(my_pk) |> pull(DATA_GROUP_ID) |> unique() |> length()

save(my_pk, file = "data-raw/temp_pk.rda")

write_csv(
  eval_tkstats(my_pk),
  file = paste0(
    Sys.getenv("FIG_DIR"),
    "2025_07_31_eval_tkstats.csv"
  )
)



```






