---
title: "PK object batch mode trial"
author: "Gilberto Padilla Mercado"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)

library(tidyverse, quietly = TRUE)
devtools::load_all() # Loads the invivopkfit package in feature/pkS3obj_facet branch
tidyverse_conflicts()
```

## Working with one DTXSID + Species combination

The first step is understanding how to work with a single DTXSID + Species combination.
Once we know how to do this, it will be easier to apply it to (potentially)
a list of these objects in a vectorized fashion.
Here I subset the `cvt` object and use that as my working data.

```{r data_loading}
# There are 103 unique chemicals in this object
cvt %>% pull(chemicals_analyzed.dsstox_substance_id) %>%
  unique() %>%
  length()

my_predata <- subset(cvt,
                     chemicals_analyzed.dsstox_substance_id %in% c("DTXSID0020442",
                                                                   "DTXSID2021731"))
```

Next, I want to follow the steps required for the particular analysis I would like.
In this instance, I set the optimizer to "L-BFGS-B" and dose-normalize the output.
I do not scale the time or log-transform the concentration values.
Since I would like to do a "Pooled" analysis,
I set the `error_group = vars(Chemical, Species)`.

```{r single_fit}
my_pk <- pk(data = my_predata) +
  facet_data(vars(Chemical, Species)) +
  settings_preprocess(keep_data_original = TRUE) +
  settings_optimx(method = c("L-BFGS-B", "bobyqa")) +
  scale_conc(dose_norm = TRUE, log10_trans = FALSE) +
  # scale_time() +
  # stat_model() + 
  stat_error_model(error_group = vars(Chemical, Species, Reference)) 

my_pk <- do_preprocess(my_pk)

my_pk <- do_data_info(my_pk) 
# summarizes error (Returning more or less than 1 row per summarize)

my_pk <- do_prefit(my_pk)

my_pk <- do_fit(my_pk)
```

Batch mode works, now I need to write a function that recapitulates `coef()` method

```{r after_method_update}
# Changed pk_methods coef() and predict() to those above
# Ran the following after making the pk object:
devtools::load_all()

my_coefs_update <- coef(my_pk)
my_pred_update <- predict(my_pk,
                          exclude = TRUE, # add the "exclude" column to output
                          use_scale_conc = TRUE)



my_pred2 <- predict(my_pk,
                    newdata = data.frame(Chemical = "DTXSID2021731",
                                         Species = "rat",
                                         Route = "iv",
                                         Media = "plasma",
                                         Dose = 20,
                                         Time = 1.6,
                                         Time.Units = "hours"),
                    exclude = FALSE,
                    use_scale_conc = FALSE)

rmse(my_pk) %>% View("RMSE_test")
residuals(my_pk) %>% View("Residuals_test")

# Seems to have worked!
```


```{r plotting_method}
# Experimenting with what works with my_ndf
# 
my_ndf <- my_pk$data

my_ndf %>%
  filter(Chemical %in% "DTXSID0020442", Species %in% "rat") %>%
  mutate(Dose = factor(Dose),
         Reference = factor(Reference),
         Detect_int = as.character(Detect)
         ) %>%
  ggplot(aes(
    x = Time_trans,
    y = Conc_trans,
    color = Dose,
    shape = Reference
  )) +
  geom_point(aes(
    fill = Dose,
    alpha = Detect_int
  )) +
  geom_point() +
  scale_shape_manual(values = 21:25) +
  scale_alpha_manual(values = c("FALSE" = 0, "TRUE" = 1),
                     breaks = c("TRUE", "FALSE"),
                     name = "Detect") +
  guides(shape = guide_legend(override.aes = list(fill = "black")),
         alpha = guide_legend(override.aes = list(alpha = 1,
                                                  fill = c("black", "white"),
                                                  color = "black",
                                                  shape = 21))) +
  facet_grid(rows = vars(Detect), # This is just for illustrative purposes, this would be Routes
             cols = vars(Route)) +
  theme_bw()
# Need to find a way to make this vectorized...
# probably within a mutate and map function


req_vars <- c("Time",
              "Time.Units",
              "Dose",
              "Route",
              "Media",
              "Reference",
              "Conc",
              "Conc_SD",
              "Value",
              "Value.Units",
              "Detect", "exclude")

trans_vars <- c("Time_trans",
                "Time_trans.Units",
                "Conc_trans",
                "Conc_trans.Units")

my_ndf %>%
  dplyr::select(Chemical, Species,
                dplyr::all_of(req_vars),
                dplyr::any_of(trans_vars)) -> my_ndf

# Time interpolation
my_ndf %>% uncount(1) %>% 
  group_by(Dose, Route, Media) %>%
  mutate(Time_trans = (max(Time)/(n() - 1))*(row_number() - 1)) %>%
  View()


devtools::load_all()
my_plot <- plot(my_pk)


my_plot[[3]][[2]] %>%
  dplyr::select(Time, Dose, Route, Media, Reference) %>% View("reduced")

my_plot[[3]][[2]] %>%
  tidyr::uncount(3) %>%
  arrange(Time) %>%
  group_by(across(!starts_with("Time"))) %>% 
  mutate(Time = seq(from = min(Time),
                    to = max(Time),
                    length.out = length(Time))) %>% View()

# Testing the stat_function way
# 
my_plot$observation_plot[[2]] +
  ggplot2::stat_function(fun = \(x) {
    sqrt(1/x)
    },
    aes(linetype = "solid"),
                         inherit.aes = FALSE)

my_statfun <- ggplot2::stat_function(fun = \(x) {
    sqrt(5*x)
    },
    aes(linetype = "dotted"),
    inherit.aes = FALSE) 
my_statfun2 <- ggplot2::stat_function(fun = \(x) {
    0.5*x
    },
    aes(linetype = "solid"),
    inherit.aes = FALSE) 
# Note that we cannot add ggproto objects together! But I can make them into a list
# and add that to the main object

my_plot$observation_plot[[2]] + list(my_statfun, my_statfun2)

my_plot$observation_plot[[2]] + my_statfun +
  scale_linetype_identity()
```



```{r remaining_methods}
# plot()
# coef_sd
# logLik.pk
# get_tkstats()



my_tkstats <- get_tkstats(my_pk)

plot_results <- plot(my_pk)


```



