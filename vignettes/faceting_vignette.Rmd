---
title: "main_vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{main_vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(invivoPKfit)
devtools::load_all()
library(magrittr)
```

# Introduction

`invivoPKfit` is an R package to automate fitting pharmacokinetic/toxicokinetic models to measured concentration vs. time toxicokinetic data.

This version of the package takes an "object-oriented" approach to this task.

This version of the package is heavily modeled after `ggplot2`, and aims to provide a "grammar of PK modeling."

The basic unit of `ggplot2` is a `ggplot` object. The basic unit of `invivopkfit` is a `pk` object.

A `ggplot2` object is essentially a data set with various instructions about how to visualize that data set. Similarly, a `pk` object is essentially a data set with various instructions about how to fit PK models to that data set.

You provide a set of instructions for building a `ggplot2` plot by adding `geom`, `stat`, `scale`, etc. commands to a `ggplot2` object (like `ggplot(my_data, aes(x=x, y=y)) + geom_point()`). Similarly, you provide a set of instructions for fitting an `invivopkfit` PK model by adding `settings`, `stat`, `scale` commands to a `pk` object.

In `ggplot2`, you can add the instructions in any order. You can overwrite old instructions by adding new ones, if you change your mind. The package will internally re-order the instructions in the correct order to build the plot. `invivopkfit` works exactly the same way.

And just as `ggplot2` doesn't actually build the plot until you issue a `print` command, `invivoPKfit` doesn't actually fit the model until you issue  a `fit` command.


# A worked example

Here's a basic example.


## Initialize a faceted `pk` object

Now, initialize a faceted `pk` object.  This contains the data, along with a set of instructions for how to do the model fitting. Note that none of the instructions have actually been carried out yet. At this point, the `pk` object is just the data and the list of instructions.

let's select the first five unique combinations of chemical and species in CvTdb, for the sake of a tractable example.

```{r}
cvt_sub <- cvt %>% dplyr::group_by(analyte_dtxsid,
                                   species) %>%
  dplyr::mutate(group_id = dplyr::cur_group_id()) %>%
  dplyr::filter(group_id %in% 1:5)
```


```{r}
my_pk <- pk(data = cvt_sub) +
  facet_data(ggplot2::vars(Chemical, Species)) +
  settings_preprocess(keep_data_original = FALSE,
                      suppress.messages = FALSE)
```

The instructions aren't carried out until you explicitly ask for them to be carried out, by calling functions that implement steps in the model fitting workflow.

The model fitting workflow has four steps.

## Model fitting workflow

### Step 1: Pre-processing data

The first is data pre-processing. Here, variable names are harmonized, and the data set is cleaned, filtered, and missing values are imputed when necessary. Instructions for this data pre-processing step are given in `my_pk$settings_preprocess`.
s
```{r}
#preprocess data
my_pk <- do_preprocess(my_pk)
```

This step adds the pre-processed data to the `pk` object in a new element named `data`.

### Step 2: Data info
 
Next, some summary information is gathered about the data. These are things like the number of detects/non-detects, broken out by the different routes and media present in the data. This step also includes non-compartmental analysis of the data, to calculate things like the empirical Cmax (maximum concentration), empirical tmax (time of maximum concentration), and empirical AUC (area under the concentration-time curve). Instructions for this "data info" step are given in `my_pk$settings_data_info`.

```{r}
#get summary data info
my_pk <- do_data_info(my_pk)
```

This step adds the data summary info to the `pk` object in a new element named `data_info`.

### Step 3: Pre-fitting

Next, a "pre-fitting" step is performed. This step looks at the data, along with the PK models to be fitted, and defines the following:

- Which of the PK model parameters are to be fitted. For example, if there is no oral data, then parameters that define oral absorption rate and oral bioavailability will not be fitted.
- The lower and upper bounds for the PK model parameters to be fitted, which may be constant or may be derived from the data in some way.
- A starting guess at the value for each PK model parameter to be fitted, which may be constant or may be derived from the data in some way.

```{r}
#pre-fitting (get model parameter bounds & starting values)
my_pk <- do_prefit(my_pk)
```

This step adds the parameter lower/upper bounds and starting guesses to the `pk` object.

### Step 4: Model fitting

Finally, the model fitting can be performed.

```{r}
#model fitting
my_pk <- do_fit(my_pk)
```

This step adds the fitted model parameter values to the `pk` object. If multiple models were fitted, and/or if multiple optimization algorithms ("methods") were used to do the fitting, then one set of fitted model parameter values is added for each model and each optimization algorithm ("method").
