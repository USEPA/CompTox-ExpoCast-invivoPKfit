---
title: "manuscript2023"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{manuscript2023}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r init, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


# Overview

This vignette outlines the 2023 manuscript that describes _invivoPKfit_'s use 
in a case study with CvT data from over 200 Chemicals. The main inquiry is to
assess whether we can estimate parameters for one- and two-compartment models
such that the majority of predicted values are "within a factor of two" -- a
common metric used to evaluate physiologically-based pharmacokinetic 
(PBPK) models.


```{r setup}
set.seed(2023)
library(tidyverse, quietly = TRUE)
library(cowplot)
library(RColorBrewer)
devtools::load_all() 
today <- format(Sys.Date(), "%d%B%Y")
```

To speed up analysis in sections 4 and beyond, we can load an `.rds` file 
that includes the fitted models used in much of the publication.

``` {r file_load, eval=FALSE}
my_pk <- readRDS("data-raw/all_cvt_pk.rds")
```


# Table of Contents

1. Pulling Data from CvTdb  
  - Minimal `pk` object  
2. Running all possible fitting options  
  - Evaluating fitting options  
  - Head-to-head comparison of pooled vs joint models  
3. Running dose-normalized, log-transformed, joint fits  
4. Analysis Plots  
  - CvTdb replicate variation (Figure 4A & Supp. Figure 2A)  
  - CvTdb replicate variation over ADME-normalized time (Figure 4B)  
  - CvTdb concentration and final time-point distributions (Supp. Figure 2B)  
  - invivoPKfit fit option selection (Supp. Table 1)  
  - invivoPKfit model performance (Supp. Figure 2)  
  - Model performance vs Data variability (Figure 5 and Alternative)  
  - Goodness of fit plots (Figure 6)  
  - Fits that may be improved (Supplementary Figure 3)  
5. Lombardo Analysis  
  - Chemicals included  
  - Comparison of derived TK stats  (Figure 7A)  
  - Histograms for Steady-state Volume of Dist. and Total Clearance (Supplemental Figure 4)
6. Benchmarking invivoPKfit
  - Parallelization speeds up the process of fitting (Supplementary Figure 5)


# Pulling data from CvTdb

See `pulling_iv_oral_cvtdb.Rmd`.

# Minimal PK object

The following chunk shows the column/field mapping from the `cvt` object and
the `pk` object needed for invivoPKfit analysis.
The `cvt` object is data from the CvTdb database that includes chemicals with
oral or intravenous routes of administration and takes measurements from
blood or plasma. The data has been processed and cleaned to facilitate its use
with _invivoPKfit_.

```{r pk_obj_fromSQL, eval=FALSE}

### Minimal PK Object ###----
# Minimum pk object, add options later
# Note that these mappings are now a default mappings, just being verbose here.
# If there are any standard deviations that are zero or NA, but N_Subjects > 1,
# Set the n_subjects to 6 or the current value if lower than 6.
# (In Showa the mode is 6, but this condition is present in CVT_Legacy as well)
minimal_pk <- pk(data = cvt %>%
                   mutate(n_subjects_normalized = if_else(
                     n_subjects_normalized > 1 & is.na(invivPK_conc_sd),
                     min(n_subjects_normalized, 6), n_subjects_normalized)),
                 mapping = ggplot2::aes(
                   Chemical = analyte_dtxsid,
                   Chemical_Name = analyte_name_original,
                   DTXSID = analyte_dtxsid,
                   CASRN = analyte_casrn,
                   Species = species,
                   Reference = fk_extraction_document_id,
                   Media = conc_medium_normalized,
                   Route = administration_route_normalized,
                   Dose = invivPK_dose_level,
                   Dose.Units = "mg/kg",
                   Subject_ID = fk_subject_id,
                   Series_ID = fk_series_id,
                   Study_ID = fk_study_id,
                   ConcTime_ID = conc_time_id,
                   N_Subjects = n_subjects_normalized,
                   Weight = weight_kg,
                   Weight.Units = "kg",
                   Time = time_hr,
                   Time.Units = "hours",
                   Value = invivPK_conc,
                   Value.Units = "mg/L",
                   Value_SD = invivPK_conc_sd,
                   LOQ = invivPK_loq
                 ))
```

# Running all possible fitting options

Here we setup the PK object with the various options for fitting and data
transformations. As shown in this vignette, it is possible to setup multiple
distinct options for fitting and data transformation at once prior to processing
and fitting the data.


```{r outlining_all_options}
# Types of Choices:
## Dose Normalized
## Log10 transform
## Scale time
# List of options
fitopts <- expand.grid(error_model = c("pooled",
                                       "hierarchical"),
                       dose_norm = c(TRUE, FALSE),
                       log10_trans = c(TRUE, FALSE),
                       time_scale = c(
                         TRUE,
                         FALSE),
                       stringsAsFactors = FALSE)
```

```{r fitting_choices, eval=FALSE}
# Make function similar to that in test_vignette authored by Caroline Ring
fit_data <- function(this_error_model,
                     this_dose_norm,
                     this_log10_trans,
                     this_time_scale,
                     n_cores = 12,
                     file_dir = Sys.getenv("OD_DIR")){
  retval <- -9
   dose_indic <- as.numeric(this_dose_norm)
  log10_indic <- as.numeric(this_log10_trans)
  time_indic <- as.numeric(this_time_scale)
  errmodel_indic <- substr(this_error_model, 1, 1)
  
  file_str <- paste0("mypk_fit_",
                     dose_indic,
                     log10_indic,
                     time_indic,
                     errmodel_indic,
                     ".Rds")
  
  cat("Fitting: ", file_str, "\n")
  
  tryCatch(
    expr = {
      this_pk <-   minimal_pk +
        facet_data(vars(Chemical, Species)) +
        settings_preprocess(keep_data_original = FALSE,
                            suppress.messages = TRUE) +
        scale_conc(dose_norm = this_dose_norm, log10_trans = this_log10_trans) +
        settings_optimx(method = c(
          "L-BFGS-B",
          "bobyqa"
          ))
      
      if(this_error_model %in% "pooled"){
        this_pk <- this_pk +
          stat_error_model(error_group = vars(Chemical, Species)) 
      } else if(this_error_model %in% c("hierarchical", "joint")){
        this_pk <- this_pk +
          stat_error_model(error_group = vars(Chemical, Species, Reference)) 
      } else{
        stop("this_error_model must be either 'pooled' or 'hierarchical'/'joint'")
      }
      
      if(this_time_scale %in% TRUE){
        this_pk <- this_pk +
          scale_time(new_units = "auto")
      }
      
      #do the fit
      this_time <- system.time(this_fit <- do_fit(this_pk, n_cores = n_cores))
      
      
      
      #save the result
      saveRDS(this_fit,
              file = paste0(file_dir,
                     file_str))
      
      cli::cli_alert_success(text = "Fitting success!")
      print(this_time)
      
      retval <- this_time[[3]]
    },
    error = function(e){
      cli::cli_alert_danger(text = paste("Analysis",
                                         file_str,
                                         "failed with error",
                                         e))
      retval <- -1
    }
  )
  
  return(retval)
}
```

```{r running_all_options, eval=FALSE}

system.time(tmp_out <- mapply(fit_data,
                              this_error_model = fitopts$error_model,
                              this_dose_norm = fitopts$dose_norm,
                              this_log10_trans = fitopts$log10_trans,
                              this_time_scale = fitopts$time_scale,
                              n_cores = 14))

mean(tmp_out)/60 # Average runtime (in minutes) per fitting option
median(tmp_out)/60
sum(tmp_out) # Looks like there's 10 extra seconds of overhead for non-fitting methods
```

# Characterizing the data

Load in one of the saved fit objects; it doesn't matter which one, since we will be using only the pre-processed data, which is the same regardless of fitting options.

```{r}
my_pk <- readRDS(paste0(Sys.getenv("OD_DIR"), "mypk_fit_110p.Rds"))
```


## Evaluating time and concentration ranges

```{r}
### Supp. Figure 2: Concentration and final time-points have wide range

data_range <- my_pk$data %>%
  filter(Detect, !exclude) %>%
  group_by(Chemical, Species, Reference, Media, Route, Dose, Dose.Units) %>%
  summarize(maxT = max(Time)/24,
         concRange = log10(max(Conc)/min(Conc))) %>%
  ungroup()
   
  
sf_2A <- data_range %>%
  ggplot(aes(x = maxT)) +
  geom_histogram(fill = "grey5",
                 bins = 40,
                 color = "grey5") +
  scale_x_log10(labels = scales::number,
                breaks = c(0.1, 1, 7, 30, 365)) +
  labs(x = "Day of final Timepoint",
       y = "Count") +
  theme(aspect.ratio = 1,
        text = element_text(size = 10),
        panel.border = element_rect(color = "black", fill = NA, size = 1),
        panel.background = element_blank(),
        panel.grid.major = element_line(color = "grey90", linewidth = 0.5),
        axis.ticks = element_blank(),
        axis.line = element_blank())

sf_2A


sf_2B <- data_range %>%
  ggplot(aes(x = concRange)) +
  geom_histogram(fill = "grey5",
                 bins = 40,
                 color = "grey5") +
  scale_y_continuous(expand = c(0, 0),
                     limits = c(0, 50),
                     breaks = c(0, 25, 50)) +
  labs(x = "log10(Concentration Range)",
       y = "Count") +
  theme(aspect.ratio = 1,
        panel.border = element_rect(color = "black", fill = NA, size = 1),
        panel.background = element_blank(),
        panel.grid.major = element_line(color = "grey90", linewidth = 0.5),
        strip.background = element_rect(fill = "white"),
        strip.text = element_text(face = "bold"),
        axis.ticks = element_blank(),
        axis.line = element_blank(),
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 11))

sf_2B

sf_2AB <- plot_grid(sf_2A, sf_2B,
                    labels = c("A", "B"), 
                    nrow = 1)

sf_2AB

ggsave(paste0(Sys.getenv("FIG_DIR"),
              "Supp_Fig2_ConcTimeRanges",
              today,
              ".pdf"),
       height = 3.2,
       width = 6,
       bg = "white",
       units = "in")

ggsave(paste0(Sys.getenv("FIG_DIR"),
              "Supp_Fig2_ConcTimeRanges",
              today,
              ".png"),
       height = 3.2,
       width = 6,
       bg = "white",
       units = "in",
       dpi = 300)

rm(sf_2A, sf_2B, sf_2AB)

```


## Evaluating data variability

### Figure 3

```{r}

my_tf <- my_pk %>% twofold_test()
```

Panel A:
```{r}
pl3A <- my_tf$individual_data %>%
  # Plotting
  ggplot(aes(x = foldConc)) +
  geom_histogram(binwidth = 0.2,
                 fill = "grey5",
                 color = "grey5",
                 linewidth = 0.4) +
  coord_cartesian(xlim =  c(0, 4),
                  ylim = c(0, 3200)) +
  scale_y_continuous(expand = c(0, 0),
                     breaks = c(0, 1000, 2000, 3000),
                     labels = c("0", "1", "2", "3")) +
  expand_limits(y = 0) +
  geom_vline(xintercept = c(0.5, 2), color = "red3", linetype = "dashed") +
  theme_bw() +
  labs(x = "Mean-normalized concentration",
                y = "Observations thousands)") +
  theme(text = element_text(size = 14),
        panel.border = element_rect(color = "black", linewidth = 1, fill = NA),
        panel.background = element_blank(),
        panel.grid.major.y = element_line(color = "grey90", linewidth = 0.4),
        axis.title = element_text(face = "bold"),
        axis.line = element_blank(),
        axis.text = element_text(size = 14),
        plot.background = element_blank(),
        axis.ticks.y = element_blank())

pl3A
```

Figure 3 Panel B: 

```{r}
my_nca <- nca(my_pk) %>%
  dplyr::filter(param_name %in% "tmax")
```

```{r}

pl3B <- my_tf$individual_data %>%
  inner_join(my_nca %>%
              dplyr::select(Chemical, Species,
                            Route, Media,
                            tmax = param_value) %>%
              filter(!is.na(tmax))) %>%
  group_by(Chemical,
           Species,
           Reference,
           Route,
           Media,
           Dose) %>%
  mutate(
         normTime = ifelse(
           Route == "iv",
           1 + Time/max(Time),
           ifelse(
             Time > tmax,
             ((Time - tmax)/max(Time)) + 1,
             0.5 + Time/(2*tmax)
           )
         )) %>%
  ggplot(aes(
    x = normTime,
    y = foldConc
  )) +
  scale_x_continuous(breaks = c(1,2),
                     labels = c("tmax", "end")) +
  geom_point(alpha = 0.1, size = 0.7) +
  # geom_vline(xintercept = 1, color = "blue",
  #            linewidth = 0.8, linetype = "dashed") +
  # geom_vline(xintercept = 2, color = "green4",
  #            linewidth = 0.8, linetype = "dashed") +
  geom_hline(yintercept = c(0.5, 2), color = "red3",
             linewidth = 0.8, linetype = "dashed") +
  facet_grid(cols = vars(Route),
             scales = "free_x") +
  labs(x = "ADME-Normalized Time",
       y = "Mean-Normalized\nConcentration") +
  theme(text = element_text(size = 14),
        panel.border = element_rect(color = "black", fill = NA, size = 1),
        panel.background = element_blank(),
        panel.grid.major = element_line(color = "grey90", linewidth = 0.5),
        strip.background = element_rect(fill = "white"),
        strip.text = element_text(face = "bold"),
        #axis.ticks = element_blank(),
        axis.line = element_blank(),
        #axis.text.x = element_blank(),
        axis.text = element_text(size = 14),
        axis.title = element_text(face = "bold"),
        panel.spacing = unit(0.125, units = "in"),
        plot.background = element_blank(),
        legend.position = "none")

pl3B
```

Paste these two plots together

```{r}
pl3 <- cowplot::plot_grid(pl3A,
                          pl3B,
                          ncol = 2,
                          rel_widths = c(1,2),
                          labels = c("A", "B"))

ggsave(paste0(Sys.getenv("FIG_DIR"),
                "Manu_Files/",
                "Fig3_",
                today,
                ".pdf"),
      pl3,
          bg = "white",
      width = 8,
      height = 4,
      units = "in")

ggsave(paste0(Sys.getenv("FIG_DIR"),
                "Manu_Files/",
                "Fig3_",
                today,
                ".png"),
      pl3,
          bg = "white",
      width = 8,
      height = 4,
      units = "in",
      dpi = 300)
```

```{r}
rm(my_pk, my_tf,
   pl3A, pl3B, pl3)
```

Histogram by time? This is effectively supplemental figure 2C

```{r}
pl2C <- my_tf$individual_data %>%
  inner_join(my_nca %>%
              dplyr::select(Chemical, Species,
                            Route, Media,
                            tmax = param_value) %>%
              filter(!is.na(tmax))) %>%
  group_by(Chemical,
           Species,
           Reference,
           Route,
           Media,
           Dose) %>%
  mutate(
         normTime = ifelse(
           Route == "iv",
           1 + Time/max(Time),
           ifelse(
             Time > tmax,
             ((Time - tmax)/max(Time)) + 1,
             0.5 + Time/(2*tmax)
           )
         )) %>%
  ggplot(aes(
    x = normTime
  )) +
  scale_x_continuous(breaks = c(1,2),
                     labels = c("tmax", "end")) +
  geom_histogram() +
  facet_grid(cols = vars(Route),
             scales = "free_x") +
  labs(x = "ADME-Normalized Time",
       "# Observations") +
  theme(text = element_text(size = 14),
        panel.border = element_rect(color = "black", fill = NA, size = 1),
        panel.background = element_blank(),
        panel.grid.major = element_line(color = "grey90", linewidth = 0.5),
        strip.background = element_rect(fill = "white"),
        strip.text = element_text(face = "bold"),
        #axis.ticks = element_blank(),
        axis.line = element_blank(),
        #axis.text.x = element_blank(),
        axis.text = element_text(size = 14),
        axis.title = element_text(face = "bold"),
        panel.spacing = unit(0.125, units = "in"),
        plot.background = element_blank(),
        legend.position = "none")

pl2C

ggsave(paste0(Sys.getenv("FIG_DIR"),
                "Manu_Files/",
                "Supp_Fig2C_",
                today,
                ".png"),
      pl2C,
          bg = "white",
      width = 8,
      height = 4,
      units = "in",
      dpi = 300)

ggsave(paste0(Sys.getenv("FIG_DIR"),
                "Manu_Files/",
                "Supp_Fig2C_",
                today,
                ".pdf"),
      pl2C,
          bg = "white",
      width = 8,
      height = 4,
      units = "in")
```



# Evaluating fitting options

Here we evaluate the various fitting options by:  

+ Counting the number of 1-, 2-compartment and flat model fits that had lowest AIC (winning model).  
+ Summarizing the root mean squared log10 error between model fit and NCA approximation of:  
  + Cmax
  + AUC_infinity
  + (Counts and filters extreme values of log10(model/NCA) > log10(20) for AUC_infinity)  
  + (Counts and filters non-finite and zero values of AUC_infinity)
+ A summary goodness-of-fit table for each data group's winning model and fitting options that includes:  
  + R-squared  
  + RMSLE  
  + AIC  
+ All predictions for each data group and fitting option (winning models only)  
+ Model errors within a factor of two for each fitting option 

```{r}
Sys.setenv(OD_DIR = "C:/Users/cring/OneDrive - Environmental Protection Agency (EPA)/invivopkfit work/Manuscript/vignette_input/mypk_fits/",
           FIG_DIR = "C:/Users/cring/OneDrive - Environmental Protection Agency (EPA)/invivopkfit work/Manuscript/vignette_output/")
```


Define some helper functions to do the various model evaluations.

Winning model tally:

```{r Winmodelfn}
# Evaluation
# Winning Model Tally
winmodel_comparison <- function(this_error_model,
                             this_dose_norm,
                             this_log10_trans,
                             this_time_scale) {
  dose_indic <- as.numeric(this_dose_norm)
  log10_indic <- as.numeric(this_log10_trans)
  time_indic <- as.numeric(this_time_scale)
  errmodel_indic <- substr(this_error_model, 1, 1)
  
  file_str <- paste0(Sys.getenv("OD_DIR"),
                     "mypk_fit_",
                     dose_indic,
                     log10_indic,
                     time_indic,
                     errmodel_indic,
                     ".Rds")
  pk_name <- paste0(dose_indic, log10_indic, time_indic, errmodel_indic)
  
  current_rds <- readRDS(file = file_str)
  
  pf <- current_rds$fit %>%
    distinct(Chemical, Species, model, method, convcode) %>%
    group_by(method, .drop = FALSE) %>%
    count(convcode) %>%
    pivot_wider(names_from = convcode,
                names_prefix = "convcode.",
                values_from = n)
    
  
  
  # Wide winning model
  suppressMessages({
    winning_model <- get_winning_model(obj = current_rds)
    wide_winning_model <- winning_model %>%
      group_by(method, model) %>%
      count() %>%
      pivot_wider(names_from = model, values_from = n) %>%
      left_join(pf)
  })
  return(wide_winning_model)
}
```

RMSLE for Cmax and AUC (with some tallys for extreme values):

First we need to determine how to filter out cases where NCA or tkstats predicted ridiculously large AUCs.

```{r}
AUC_plot <- function(
    this_error_model,
    this_dose_norm,
    this_log10_trans,
    this_time_scale) {
  dose_indic <- as.numeric(this_dose_norm)
  log10_indic <- as.numeric(this_log10_trans)
  time_indic <- as.numeric(this_time_scale)
  errmodel_indic <- substr(this_error_model, 1, 1)
  
  file_str <- paste0(Sys.getenv("OD_DIR"),
                     "mypk_fit_",
                     dose_indic,
                     log10_indic,
                     time_indic,
                     errmodel_indic,
                     ".Rds")
  pk_name <- paste0(dose_indic, log10_indic, time_indic, errmodel_indic)
  
  message(paste0("Evaluation for: ", pk_name))
  current_rds <- readRDS(file = file_str)
  # Cmax and AUC_inf RMSEs
  #note that eval_tkstats already filters winning models
  #use finite_only = FALSE so that we can count the excluded cases
  suppressMessages(RMSLE_eval <- eval_tkstats(obj = current_rds, 
                                             dose_norm = FALSE,
                                             finite_only = FALSE,
                                             suppress.messages = TRUE) %>%
                                  mutate(Options = pk_name) %>%
                                  dplyr::select(
                                    Options,
                                    Chemical,
                                    Species,
                                    Route,
                                    Media,
                                    Reference,
                                    method,
                                    model,
                                    starts_with("Cmax"),
                                    starts_with("AUC_")
                                  ))
  
 these_opts <- paste0(dose_indic,
                     log10_indic,
                     time_indic,
                     errmodel_indic)
  
  #plot AUC infinity for tkstats vs. AUC infinity for NCA
   #show identity line and 20x above and below lines
 AUC_plot <- RMSLE_eval %>%
    dplyr::filter(is.finite(AUC_infinity.nca) & is.finite(AUC_infinity.tkstats)) %>%
    ggplot() +
    geom_point(aes(x = AUC_infinity.nca,
                   y = AUC_infinity.tkstats,
                   color = model)) +
    scale_x_log10() + scale_y_log10() +
    annotation_logticks() +
    geom_abline(aes(intercept = 0, slope =1)) +
    geom_abline(aes(intercept = log10(20), slope = 1),
                linetype = 2) +
    geom_abline(aes(intercept = log10(1/20), slope = 1),
                linetype = 2) +
      facet_grid(rows = vars(method)) +
      ggtitle(paste(these_opts,
                    "AUC_inf pred vs. AUC_inf NCA")) +
      scale_color_manual(values = c("model_1comp" = "#0398FC",
                                 "model_2comp" = "#D68E09",
                               "model_flat" = "black"),
                    name = "Winning model") +
      coord_equal()
 
 Cmax_plot <- RMSLE_eval %>%
    dplyr::filter(is.finite(Cmax.nca) & is.finite(Cmax.tkstats)) %>%
    ggplot() +
    geom_point(aes(x = Cmax.nca,
                   y = Cmax.tkstats,
                   color = model)) +
    scale_x_log10() + scale_y_log10() +
    annotation_logticks() +
    geom_abline(aes(intercept = 0, slope =1)) +
    geom_abline(aes(intercept = log10(20), slope = 1),
                linetype = 2) +
    geom_abline(aes(intercept = log10(1/20), slope = 1),
                linetype = 2) +
      facet_grid(rows = vars(method)) +
      ggtitle(paste(these_opts,
                    "Cmax pred vs. Cmax NCA")) +
      scale_color_manual(values = c("model_1comp" = "#0398FC",
                                 "model_2comp" = "#D68E09",
                               "model_flat" = "black"),
                    name = "Winning model") +
      coord_equal()

  return(
    list(AUC_plot = AUC_plot,
    Cmax_plot = Cmax_plot
    )
  )
}
```

Run this for all fitting opts

```{r}
all_AUC_plots <- fitopts %>%
              dplyr::rowwise() %>%
  dplyr::summarise(this_plot = list(AUC_plot(this_error_model = error_model,
                                 this_dose_norm = dose_norm,
                                 this_log10_trans = log10_trans,
                                 this_time_scale = time_scale)
                                 )
                   )
#save the plots
pdf(file = paste0(
  Sys.getenv("FIG_DIR"),
  today,
  "AUCinf_nca_vs_tk_plots.pdf"),
  onefile = TRUE,
  height = 5,
  width = 7)

plotlist <- all_AUC_plots %>%
  pull(this_plot)

for (x in seq_along(plotlist)) {
  print(plotlist[[x]][["AUC_plot"]])
}
dev.off()

pdf(file = paste0(
  Sys.getenv("FIG_DIR"),
  today,
  "Cmax_nca_vs_tk_plots.pdf"),
  onefile = TRUE,
  height = 5,
  width = 7)

plotlist <- all_AUC_plots %>%
  pull(this_plot)

for (x in seq_along(plotlist)) {
  print(plotlist[[x]][["Cmax_plot"]])
}
dev.off()

rm(plotlist, all_AUC_plots)
```

It appears that the best filter, other than filtering out NA, Inf, zero, and negative values, would be to filter out any AUC_inf values greater than 1e7, since that cutoff identifies outliers.

```{r RMSLE_Cmax_AUC_fun}

# RMSLE for Cmax and AUC (with some tallys for extreme values)
rmsles_Cmax_AUC <- function(
    this_error_model,
    this_dose_norm,
    this_log10_trans,
    this_time_scale) {
  dose_indic <- as.numeric(this_dose_norm)
  log10_indic <- as.numeric(this_log10_trans)
  time_indic <- as.numeric(this_time_scale)
  errmodel_indic <- substr(this_error_model, 1, 1)
  
  file_str <- paste0(Sys.getenv("OD_DIR"),
                     "mypk_fit_",
                     dose_indic,
                     log10_indic,
                     time_indic,
                     errmodel_indic,
                     ".Rds")
  pk_name <- paste0(dose_indic, log10_indic, time_indic, errmodel_indic)
  
  message(paste0("Evaluation for: ", pk_name))
  current_rds <- readRDS(file = file_str)
  # Cmax and AUC_inf RMSEs
  #note that eval_tkstats already filters winning models
  #use finite_only = FALSE so that we can count the excluded cases
  suppressMessages(RMSLE_eval <- eval_tkstats(obj = current_rds, 
                                             dose_norm = FALSE,
                                             finite_only = FALSE,
                                             suppress.messages = TRUE) %>%
                                  mutate(Options = pk_name) %>%
                                  dplyr::select(
                                    Options,
                                    Chemical,
                                    Species,
                                    Route,
                                    Media,
                                    Reference,
                                    method,
                                    model,
                                    starts_with("Cmax"),
                                    starts_with("AUC_")
                                  ))
 
  #COunt bad observations:
  #zero, NA, infinite
  RMSLE_badobs <- RMSLE_eval %>% 
    group_by(Options, method, model) %>%
    summarise(total_expts = n(),
              count_AUCinf_NCA_0 = sum(AUC_infinity.nca %in% 0),
              count_AUCinf_pred_0 = sum(AUC_infinity.tkstats %in% 0),
              count_AUCinf_NCA_isNA = sum(is.na(AUC_infinity.nca)),
              count_AUCinf_pred_isNA = sum(is.na(AUC_infinity.tkstats)),
              count_AUCinf_NCA_isInf = sum(is.infinite(AUC_infinity.nca)),
              count_AUCinf_pred_isInf = sum(is.infinite(AUC_infinity.tkstats)),
             count_Cmax_NCA_0 = sum(Cmax.nca %in% 0),
              count_Cmax_pred_0 = sum(Cmax.tkstats %in% 0),
              count_Cmax_NCA_isNA = sum(is.na(Cmax.nca)),
              count_Cmax_pred_isNA = sum(is.na(Cmax.tkstats)),
              count_Cmax_NCA_isInf = sum(is.infinite(Cmax.nca)),
              count_Cmax_pred_isInf = sum(is.infinite(Cmax.tkstats))
    ) %>%
    ungroup()
  
  #count cases where AUC or Cmax was negative
  RMSLE_neg <- RMSLE_eval %>%
    dplyr::filter(is.finite(AUC_infinity.nca),
                            is.finite(AUC_infinity.tkstats),
                            is.finite(Cmax.nca),
                            is.finite(Cmax.tkstats)) %>%
    group_by(Options, method, model) %>%
      summarise(count_AUCinf_NCA_lt0 = sum(AUC_infinity.nca < 0),
              count_AUCinf_pred_lt0 = sum(AUC_infinity.tkstats < 0),
              count_Cmax_NCA_lt0 = sum(AUC_infinity.nca < 0),
              count_Cmax_pred_lt0 = sum(AUC_infinity.tkstats < 0),
              count_AUCinf_NCA_gt_1e7 = sum(AUC_infinity.nca > 1e7),
               count_AUCinf_pred_gt_1e7 = sum(AUC_infinity.tkstats > 1e7),
       )
  
  RMSLE_badobs <- RMSLE_badobs %>%
    left_join(RMSLE_neg, by = c("Options",
                                    "method",
                                "model")) %>%
        rowwise() %>%
    dplyr::mutate(total_excl = sum(
      c_across(
      starts_with("count")
      )
      )
    )
  
  
  RMSLE_eval <- RMSLE_eval %>%
    dplyr::filter(is.finite(AUC_infinity.nca),
           is.finite(AUC_infinity.tkstats)) %>%
    dplyr::filter(
      AUC_infinity.nca > 0,
      AUC_infinity.tkstats > 0,
      AUC_infinity.nca < 1e7,
      AUC_infinity.tkstats < 1e7) %>%
    rowwise() %>%
    mutate(
      SLE_Cmax = (log10(Cmax.tkstats) - log10(Cmax.nca)) ^ 2,
      SLE_AUC_inf = (log10(AUC_infinity.tkstats) - log10(AUC_infinity.nca)) ^ 2
    ) %>%
    dplyr::filter(!is.na(SLE_Cmax), !is.na(SLE_AUC_inf)) %>%
    group_by(Options, method, model) %>%
    summarise(
      n_expts = n(),
      RMSLE_Cmax = sqrt(mean(SLE_Cmax, na.rm = FALSE)) %>% signif(digits = 4),
      RMSLE_AUC = sqrt(mean(SLE_AUC_inf, na.rm = FALSE)) %>% signif(digits = 4)
    ) %>%
    ungroup()
  
  #merge in counts of bad obs
  
  RMSLE_eval <- RMSLE_eval %>%
    dplyr::left_join(RMSLE_badobs,
              by = c("Options", "method", "model")) %>%
    dplyr::rename(winning_model = model)
  
  return(RMSLE_eval)
}
```



Goodness-of-fit table with R-squared, RMSLE and AIC:

```{r gof_tbl_fun}
# Goodness-of-fit table with R-squared, RMSLE and AIC
get_gof <- function(this_error_model,
                             this_dose_norm,
                             this_log10_trans,
                             this_time_scale) {
  dose_indic <- as.numeric(this_dose_norm)
  log10_indic <- as.numeric(this_log10_trans)
  time_indic <- as.numeric(this_time_scale)
  errmodel_indic <- substr(this_error_model, 1, 1)
  
  file_str <- paste0(Sys.getenv("OD_DIR"),
                     "mypk_fit_",
                     dose_indic,
                     log10_indic,
                     time_indic,
                     errmodel_indic,
                     ".Rds")
  pk_name <- paste0(dose_indic, log10_indic, time_indic, errmodel_indic)
  
  current_rds <- readRDS(file = file_str)
  winning_model <- suppressMessages(get_winning_model(obj = current_rds))
  
  suppressMessages({
    this_rsq <- rsq.pk(current_rds,
                    use_scale_conc = FALSE,
                    rsq_group = ggplot2::vars(Chemical, Species),
                    sub_pLOQ = TRUE) %>%
      semi_join(winning_model)
    
    this_AIC <- AIC(current_rds) %>%
      semi_join(winning_model)
    
    this_rmsle <- rmse.pk(current_rds,
                      rmse_group = vars(Chemical, Species),
                      use_scale_conc = list(dose_norm = FALSE,
                                            log10_trans = TRUE),
                      sub_pLOQ = TRUE) %>%
      semi_join(winning_model)

  })
  
  # Since they are all joined by winmodel
  # all three must have same NROW
  message(
    paste0("For ", pk_name, "... outputs below must have same number of rows")
  )
  
  message(paste0("rsq: ", NROW(this_rsq)))
  message(paste0("aic: ", NROW(this_AIC)))
  message(paste0("rmsle: ", NROW(this_rmsle)))
  
  gof_df <- this_rsq %>%
    inner_join(this_AIC, by = join_by(Chemical, Species, method, model)) %>%
    inner_join(this_rmsle, by = join_by(Chemical, Species, method, model)) %>%
    mutate(Options = pk_name, .before = Chemical)
  
  return(gof_df)
}
```

Get all predictions:

```{r allpreds_fun}

# All predictions 
get_all_preds <- function(this_error_model,
                             this_dose_norm,
                             this_log10_trans,
                             this_time_scale) {
  dose_indic <- as.numeric(this_dose_norm)
  log10_indic <- as.numeric(this_log10_trans)
  time_indic <- as.numeric(this_time_scale)
  errmodel_indic <- substr(this_error_model, 1, 1)
  
  file_str <- paste0(Sys.getenv("OD_DIR"),
                     "mypk_fit_",
                     dose_indic,
                     log10_indic,
                     time_indic,
                     errmodel_indic,
                     ".Rds")
  pk_name <- paste0(dose_indic, log10_indic, time_indic, errmodel_indic)
  
  
  current_rds <- readRDS(file = file_str)
  
  # Wide winning model
  suppressMessages({
    winning_model <- get_winning_model(obj = current_rds) %>%
      select(-c(near_flat, preds_below_loq))
    this_preds <- predict(current_rds,
                          use_scale_conc = FALSE) %>%
      semi_join(winning_model) %>%
      mutate(Options = pk_name, .before = Chemical)
  })
  return(this_preds)
}
```

Factor of two model error:

```{r factor2fun}
# Factor of two model error
tf_tests <- function(this_error_model,
                             this_dose_norm,
                             this_log10_trans,
                             this_time_scale) {
  dose_indic <- as.numeric(this_dose_norm)
  log10_indic <- as.numeric(this_log10_trans)
  time_indic <- as.numeric(this_time_scale)
  errmodel_indic <- substr(this_error_model, 1, 1)
  
  file_str <- paste0(Sys.getenv("OD_DIR"),
                     "mypk_fit_",
                     dose_indic,
                     log10_indic,
                     time_indic,
                     errmodel_indic,
                     ".Rds")
  pk_name <- paste0(dose_indic, log10_indic, time_indic, errmodel_indic)
  current_rds <- readRDS(file = file_str)
  print(paste0("Now analyzing: ", pk_name))
  
  out <- twofold_test(current_rds,
                      sub_pLOQ = TRUE,
                      suppress_messages = TRUE)
  
  out <- out$model_error_summary %>%
    mutate(Options = pk_name)
  
  return(out)
}

```


Now call these functions and do the evaluations.

Winning model comparisons:

```{r do_winmodel}

#winning model
system.time(wm_comp <- fitopts %>%
              dplyr::rowwise() %>%
              dplyr::mutate(winmodel_comp = list(
                winmodel_comparison(this_error_model = error_model,
                                 this_dose_norm = dose_norm,
                                 this_log10_trans = log10_trans,
                                 this_time_scale = time_scale))) %>%
              tidyr::unnest(winmodel_comp))
```

RMSLE for Cmax and AUC:

```{r do_RMSLE_Cmax_AUC}

#RMSLE for Cmax and AUC
system.time(cmax_auc_rmsle_tbl <- fitopts %>%
              dplyr::rowwise() %>%
              dplyr::mutate(nca_comp = list(
                rmsles_Cmax_AUC(this_error_model = error_model,
                                 this_dose_norm = dose_norm,
                                 this_log10_trans = log10_trans,
                                 this_time_scale = time_scale))) %>%
              tidyr::unnest(nca_comp))
```

Goodness-of-fit metrics table:

```{r do_gof_tbl}

#GOF table
system.time(gof_tbl <- fitopts %>%
              dplyr::rowwise() %>%
              dplyr::mutate(gof_win = list(
                get_gof(this_error_model = error_model,
                                 this_dose_norm = dose_norm,
                                 this_log10_trans = log10_trans,
                                 this_time_scale = time_scale))) %>%
              tidyr::unnest(gof_win))
```

Factor of two:

```{r do_factor_two}

#factor of two
system.time(all_tf_tests <- fitopts %>%
              dplyr::rowwise() %>%
              dplyr::mutate(TF = list(
                tf_tests(error_model,
                         this_dose_norm = dose_norm,
                         this_log10_trans = log10_trans,
                         this_time_scale = time_scale))) %>%
              tidyr::unnest(TF))
```

Get all predictions:

```{r do_all_preds}
#all predictions
system.time(all_preds <- fitopts %>%
              dplyr::rowwise() %>%
              dplyr::mutate(these_preds = list(
                get_all_preds(this_error_model = error_model,
                                 this_dose_norm = dose_norm,
                                 this_log10_trans = log10_trans,
                                 this_time_scale = time_scale))) %>%
              tidyr::unnest(these_preds))
```

Write the evaluation results to a spreadsheet, and also write the predictions to an RDS file.

```{r write_eval_results}

# Write the results to file
writexl::write_xlsx(x = list(
  Fit_Counts = wm_comp,
  AUC_and_Cmax_RMSE_summary = cmax_auc_rmsle_tbl,
  Prediction_Evaluations = gof_tbl,
  Twofold_Tests = all_tf_tests),
  path = paste0(Sys.getenv("FIG_DIR"),
                "Manu_Files/",
                today,
                "_Supp_Table1_eval_results",
                ".xlsx"))

rm(wm_comp, cmax_auc_rmsle_tbl, gof_tbl, all_tf_tests)
```

```{r write_preds}

#Save preds to a file as well
saveRDS(all_preds, paste0(Sys.getenv("FIG_DIR"),
                          "Manu_Files/",
                          today,
                          "_all_preds.Rds"))

rm(all_preds)
```

```{r}
gc()
```

## Plots for evaluation of fitting options

# Goodness-of-fit metrics Rsq and RMSLE across fitting options

```{r read_gof}
#read GOF table
gof_tbl <- readxl::read_xlsx(path = paste0(Sys.getenv("FIG_DIR"),
                                                   "Manu_Files/",
                                                   "22November2024",
                                                   "_Supp_Table1_eval_results.xlsx"),
                                     sheet = "Prediction_Evaluations") %>% 
  mutate(RMSLE = as.numeric(RMSLE))
```

Plot R-sq vs. RMSLE for the various fitting options, color-coding by winning model.

```{r plot_rsq_rmsle}
 gof_tbl <- gof_tbl %>%
  dplyr::mutate(opts = substr(Options, 1, 3),
                model_text = dplyr::case_when(model %in% "model_1comp" ~ "1comp",
                                              model %in% "model_2comp" ~ "2comp",
                                              model %in% "model_flat" ~ "flat",
                                              .default = NA_character_))

fig_rsq_rmsle <- ggplot(gof_tbl) +
  geom_point(aes(x = RMSLE,
                 y = Rsq,
                 color = model_text)) +
  facet_grid(rows = vars(opts),
             cols = vars(interaction(error_model, method)
                         )
             ) +
 scale_color_manual(values = c("1comp" = "#0398FC",
                                 "2comp" = "#D68E09",
                               "flat" = "black"),
                    name = "Winning model") +
  theme_bw()

fig_rsq_rmsle

```

This figure reveals two things:

First, when L-BFGS-B is the optimizer, RMSLEs are much larger for a subset of data groups compared to bobyqa.

Second, when L-BFGS-B is the optimizer, the flat model is the winning model for a much greater number of data groups, indicating that for some data groups, L-BFGS-B could not locate a reasonable set of model parameters for 1- or 2-comapartment models, but bobyqa could.

If we zoom in to RMSLE < 2:

```{r plot_rsq_rmsle_zoom}
fig_rsq_rmsle_zoom <- ggplot(gof_tbl) +
  geom_point(aes(x = RMSLE,
                 y = Rsq,
                 color = model_text)) +
  facet_grid(rows = vars(opts),
             cols = vars(interaction(error_model, method)
                         )
             ) +
 scale_color_manual(values = c("1comp" = "#0398FC",
                                 "2comp" = "#D68E09",
                               "flat" = "black"),
                    name = "Winning model") +
  coord_cartesian(xlim = c(0,1)) +
  theme_bw()

fig_rsq_rmsle_zoom
```

When each time-scaling fit (when "1" is in the last place of the fit options shorthand) is compared to the fit in the row immediately above it (the same dose-normalization and log10-transformations options, but without time scaling), it can be seen that time scaling either has little effect on goodness of fit, or it makes RMSLE and/or R-squared slightly worse.

Save these figures.

```{r}
ggsave(paste0(Sys.getenv("FIG_DIR"),
                "Manu_Files/",
                today,
                "_Supp_Fig3a_fit_opts_metrics.pdf"),
       fig_rsq_rmsle,
       width = 11,
       height = 8.5)

ggsave(paste0(Sys.getenv("FIG_DIR"),
                "Manu_Files/",
                today,
                "_Supp_Fig3b_fit_opts_metrics_zoom.pdf"),
       fig_rsq_rmsle_zoom,
       width = 11,
       height = 8.5)

ggsave(paste0(Sys.getenv("FIG_DIR"),
                "Manu_Files/",
                today,
                "_Supp_Fig3a_fit_opts_metrics.png"),
       fig_rsq_rmsle,
       width = 11,
       height = 8.5)

ggsave(paste0(Sys.getenv("FIG_DIR"),
                "Manu_Files/",
                today,
                "_Supp_Fig3b_fit_opts_metrics_zoom.png"),
       fig_rsq_rmsle_zoom,
       width = 11,
       height = 8.5)

rm(fig_rsq_rmsle_zoom, fig_rsq_rmsle)
```


### Cmax RMSLE vs. AUC RMSLE across fitting options

Plot Cmax RMSLE vs. AUC RMSLE.

```{r plot_cmax_auc_rmsle}
#read in table
cmax_auc_rmsle_tbl <- readxl::read_xlsx(path = paste0(Sys.getenv("FIG_DIR"),
                                                   "Manu_Files/",
                                                   "22November2024",
                                                  "_Supp_Table1_eval_results.xlsx"),
                                     sheet = "AUC_and_Cmax_RMSE_summary")
#make plot
cmax_auc_rmsle_tbl <- cmax_auc_rmsle_tbl %>%
  dplyr::mutate(opts = substr(Options, 1, 3))

cmax_auc_rmsle_fig <- ggplot(cmax_auc_rmsle_tbl) +
  geom_point(aes(x = RMSLE_AUC,
                 y = RMSLE_Cmax,
                 color = opts),
             size = 4) +
  facet_grid(rows = vars(error_model),
             cols = vars(method)) +
  scale_color_brewer(palette = "Paired",
                     name = "Fit options") +
  theme_bw()

cmax_auc_rmsle_fig

#save plot
ggsave(paste0(Sys.getenv("FIG_DIR"),
                "Manu_Files/",
                today,
                "_Supp_Fig3c_fit_opts_Cmax_AUC_RMSLE.pdf"),
      cmax_auc_rmsle_fig,
      width = 7,
      height = 5)

ggsave(paste0(Sys.getenv("FIG_DIR"),
                "Manu_Files/",
                today,
                "_Supp_Fig3c_fit_opts_Cmax_AUC_RMSLE.png"),
      cmax_auc_rmsle_fig,
      width = 7,
      height = 5,
      dpi = 300)

rm(cmax_auc_rmsle_fig)
```

This figure reveals that overall, L-BFGS-B produced fits that did not match NCA-estimated Cmax or AUC as well as bobyqa fits. Considering only the bobyqa fits, the pooled error model achieved the smallest differences between NCA and model-predicted Cmax and AUC, and it did so with the two sets of fitting options that included both dose-normalization and log10-transformation.

Produce and save tables for these evaluation metrics.

```{r}
(win_mdl_count_by_opts <- gof_tbl %>%
  group_by(Options, method, model) %>%
  count() %>%
  pivot_wider(names_from = model,
              values_from = n) )
```


Rank fitting options by count of Chemical-Species data groups where RMSLE < 1

```{r}
gof_tbl %>%
  group_by(Options, method) %>%
  count(RMSLE < 1) %>%
  filter(`RMSLE < 1`) %>%
  arrange(desc(n)) %>%
  print(n = 8)
# bobyqa-optimized options 010h, 110h, 110p
```

What about R-squared greater than 0.75?

```{r}
gof_tbl %>%
  group_by(Options, method) %>%
  count(Rsq > 0.75) %>%
  filter(`Rsq > 0.75`) %>%
  arrange(desc(n)) %>%
  print(n = 8)
```


What about both RMSLE < 1 and R-squared greater than 0.75?

```{r}
rmsle_rsq_rank <- gof_tbl %>%
  group_by(Options, method) %>%
  count(RMSLE < 1 & Rsq > 0.75) %>%
  filter(`RMSLE < 1 & Rsq > 0.75`) %>%
  arrange(desc(n)) %>%
  dplyr::rename(`# Chemical-Species data groups` = n) 

rmsle_rsq_rank %>% print(n=8)
```
Looking at both criteria together, it appears that the best set of fitting options is actually the simplest: 000p (no data transformation and pooled error model), bobyqa-optimized.

But also, let's add in the Cmax/AUC RMSLE calculations: Sort the fitting options from smallest to greatest RMSLE for Cmax and AUC, and see which set of fitting options yields the lowest RMSLE.


```{r}
cmax_auc_rmsle_rank <- cmax_auc_rmsle_tbl %>%
  arrange(RMSLE_Cmax, RMSLE_AUC) %>%
  select(Options, method, RMSLE_Cmax, RMSLE_AUC) 

cmax_auc_rmsle_rank %>%
  print(n = 8)
```

This ranking strongly suggests 110p, with 100p as a second choice (both bobyqa).

110p was ranked number 3 in the list of RMSLE and Rsq criteria 9and 100p was ranked number 5). So we select 110p bobyqa as the best when all of these metrics are considered.

Save these tables as an Excel spreadsheet.

```{r}
writexl::write_xlsx(list("winning model" = win_mdl_count_by_opts,
  "RMSLE Rsq rank" = rmsle_rsq_rank,
                         "Cmax AUC RMSLE rank" = cmax_auc_rmsle_rank),
                    path = paste0(Sys.getenv("FIG_DIR"),
                "Manu_Files/",
                today,
                "_Supp_Table1a_fit_opts_metrics",
                ".xlsx"))
```


Plot predicted vs. observed concentrations for everything, using the winning fit options and the winning model for each data group.

```{r}
all_preds <- readRDS(paste0(Sys.getenv("FIG_DIR"),
                          "Manu_Files/",
                          today,
                          "_all_preds.Rds"))

#select winning fit opts: 110p bobyqa

all_preds_prep <- all_preds %>%
  filter(Options %in% c("110p"),
         method %in% "bobyqa") %>%
  mutate(Conc_est_sub = dplyr::if_else(Conc_est < pLOQ,
         pLOQ,
         Conc_est),
         Conc_est_belowLOQ = dplyr::if_else(Conc_est < pLOQ,
         TRUE,
         FALSE),
         ID = as.factor(paste(Chemical, Chemical_Name, Species)),
         .keep = "unused") %>%
  select(ID, Options,
         dose_norm, log10_trans, time_scale,
         Route, Media, Dose,
         Conc, Conc_est_sub, Conc_est_belowLOQ,
         Time, Reference)

split_preds <- split(all_preds_prep, all_preds_prep$ID)

sp_plots <- lapply(names(split_preds), function(i) {
  ggplot(data = split_preds[[i]],
         mapping = aes(x = Conc,
                       y = Conc_est_sub,
                       color = as.factor(Dose),
                       shape = Reference)) +
    xlab("Observed conc, mg/L") +
    ylab("Predicted conc, mg/L") +
    geom_point(size = 2) +
    geom_abline(slope = 1) +
    facet_grid(Route ~ Media, 
               scales = "free_y") +
    scale_y_log10() +
    scale_x_log10() +
    annotation_logticks(sides = "bl") +
    scale_color_viridis_d(name = "Dose, mg/kg") +
    theme_bw() +
    labs(title = i) +
    theme(legend.position = "bottom",
          plot.title = element_text(hjust = 0.5, face = "bold"))
}
)

# Very BIG FILE
pdf(file = paste0(
  Sys.getenv("FIG_DIR"),
  today,
  "log10_GOFplots_select.pdf"),
  onefile = TRUE, height = 8, width = 8)
for (x in seq_along(sp_plots)) {
  print(sp_plots[[x]])
}
dev.off()

rm(sp_plots)
rm(split_preds)
```

## Analysis Plots



Next I will generate the figures for the paper. I will begin by collating the data
that I need. This data are generally accessible using functions/methods for evaluating
fitted `pk` objects.

```{r data_aggregation, eval=FALSE}
my_pk <- readRDS(paste0(Sys.getenv("OD_DIR"), "mypk_fit_110p.Rds"))

# Need the following data for any of the subsequent plots

# after fitting pk object for all cvt objects or reading the fitted pk object in `setup`
winmodel <- get_winning_model(my_pk, method = "bobyqa")
my_preds <- semi_join(predict(my_pk, use_scale_conc = FALSE, , method = "bobyqa"), winmodel) 
my_residuals <- residuals(my_pk, use_scale_conc = FALSE, method = "bobyqa") %>%
  semi_join(winmodel) 
my_tkstats <- eval_tkstats(my_pk, method = "bobyqa") %>% semi_join(winmodel)
my_nca <- get_nca(my_pk)
all_my_data <- get_data(my_pk)

formatted_coefs <- my_pk$fit %>% 
  filter(method %in% "bobyqa") %>%
  filter(str_detect(param_name, "sigma_", negate = TRUE)) %>%
  select(Chemical, Species, model, model, param_name, estimate,
         param_name, estimate, convcode) %>% 
  mutate(param_name = paste(param_name, "tkstats", sep = ".")) |> 
  pivot_wider(names_from = param_name,
                                     values_from = estimate)

my_tf <- twofold_test(my_pk, method = "bobyqa")  

NROW(all_my_data) > NROW(my_preds) # THis must be true... or else try distinct(my_preds)

# Writing file to xlsx
writexl::write_xlsx(x = list(predictions = my_preds,
                             tkstats = my_tkstats),
                    path = paste0(Sys.getenv("FIG_DIR"),
                                  "Manu_Files/",
                                  today,
                                  "_Supp_Table2",
                                  ".xlsx"))
```

Compute fold errors, r-squared, AIC, RMSLE, RMSE.
```{r}

fe_df <- fold_errors(my_pk, sub_pLOQ = TRUE, method = "bobyqa") %>% semi_join(winmodel)

# May need to change the use_scale_conc defaults
r2_df <- rsq(my_pk, use_scale_conc = FALSE, sub_pLOQ = TRUE, method = "bobyqa") %>%
  semi_join(winmodel)  
myAIC <- AIC(my_pk, method = "bobyqa") %>%
  semi_join(winmodel) 
myRMSLE <- rmse(my_pk,
               use_scale_conc = list(dose_norm = FALSE, log10_trans = TRUE),
               sub_pLOQ = TRUE,
               method = "bobyqa") %>% 
  semi_join(winmodel)  

myRMSE <- rmse(my_pk,
               rmse_group = ggplot2::vars(Chemical, Species, Route, Media, Dose),
               sub_pLOQ = TRUE,
               method = "bobyqa") %>%
  semi_join(winmodel) 

chem_name_translate <- all_my_data %>%
  dplyr::select(Chemical, Chemical_Name) %>%
  dplyr::filter(!(Chemical_Name %in% c("2,4-d",
                                     "methylene chloride",
                                     "benzo[a]pyrene"))) %>%
  dplyr::distinct() 

```

### Figure 4B: Variation over time in CvTdb data.

Here the goal is to evaluate whether particular ADME phases
are particularly susceptible to model error (just as we checked for data variability earlier). To do this, we create a 
relative time scale anchored by $t_{max}$ and $t_{last}$. Model error is plotted against this relative time scale, to explore whether model error is greater in particular ADME phases.

```{r fig4B-cowplot, eval=FALSE}
# Extra Plot: Model error over ADME-normalized time! ----
mydat <- my_preds %>% 
  filter(Detect, !exclude, Conc_est >= pLOQ,
         !(model %in% "model_flat")) %>%
  inner_join(my_tkstats %>%
              dplyr::select(Chemical, Species,
                            Route, Media,
                            tmax = tmax.nca) %>%
              filter(!is.na(tmax)) %>%
               semi_join(winmodel)) %>%
  group_by(Chemical,
           Species,
           Route,
           Media,
           Dose) %>%
  mutate(normTime = ifelse(
           Route == "iv",
           1 + Time/max(Time),
           ifelse(
             Time > tmax,
             ((Time - tmax)/max(Time)) + 1,
             0.5 + Time/(2*tmax)
           )
         )) %>%
  group_by(model, method,
           Chemical, Species, Route, Media,
           Dose, normTime) %>%
  summarize(RMSLE = sqrt(sum((log10(Conc) - log10(Conc_est))^2)/n()))

p <- mydat %>%
  ggplot(aes(
    x = normTime,
    y = RMSLE
  )) +
  geom_point(alpha = 0.2, size = 0.7) +
  # geom_hex() +
  # scale_fill_viridis_c(trans = "log10",
  #                      option = "cividis") +
    geom_vline(xintercept = 1, color = "blue",
             linewidth = 0.8, linetype = "dashed") +
  geom_vline(xintercept = 2, color = "green4",
             linewidth = 0.8, linetype = "dashed") +
  # geom_hline(yintercept = c(0, 1), color = "red3",
  #            linewidth = 0.8, linetype = "dashed") +
  facet_grid(cols = vars(Route),
             scales = "free_x") +
  labs(x = "ADME-Normalized Time",
       y = "RMSLE",
       title = "RMSLE over the course of an experiment") +
  theme(text = element_text(size = 10),
        panel.border = element_rect(color = "black", fill = NA, size = 1),
        panel.background = element_blank(),
        panel.grid.major = element_line(color = "grey90", linewidth = 0.5),
        strip.background = element_rect(fill = "white"),
        strip.text = element_text(face = "bold"),
        axis.ticks = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.title = element_text(face = "bold"),
        panel.spacing = unit(0.125, units = "in"),
        plot.background = element_rect(color = "white"))

ggsave(paste0(Sys.getenv("FIG_DIR"),
              today,
              "RMLE_overADME_time",
              ".png"),
       p,
       height = 3,
       width = 7,
       units = "in",
       dpi = 300)

```

### Supp Figure 3: invivoPKfit model performance

Overall fold error distributions.

```{r}
my_tf$model_error_all %>%
  filter(model %in% c("model_1comp", "model_2comp")) %>%
  mutate(Route.model = factor(paste(Route, model),
                              levels = c("iv model_1comp",
                                         "iv model_2comp",
                                         "oral model_1comp",
                                         "oral model_2comp"))) %>%
  ggplot(aes(x = Fold_Error,
             fill = Route.model)) +
  geom_histogram(color = NA,
                 position = position_stack(),
                 bins = 50) +
  scale_x_log10(labels = scales::label_math(format = log10)) +
  annotation_logticks(sides = "b") +
    scale_fill_brewer(palette = "Paired",
                      name = "Route/winning model") +
  expand_limits(y = 0) +
  geom_vline(xintercept = c(0.5, 2), color = "black", linetype = "dashed") +
  labs(x = "Predicted/Observed",
       y = "Number of Observations") +
  theme_classic() +
  theme(aspect.ratio = 1,
        panel.border = element_rect(color = "black", fill = NA),
        panel.grid.major = element_line(color = "grey95", linewidth = 0.4)) +
  coord_cartesian(xlim = c(10^(-1.5), 100))


ggsave(paste0(Sys.getenv("FIG_DIR"),
               "Manu_Files/",
                                  today,
              "Supp_Fig4_PredictedObserved_compartmentModels.png"),
       height = 5, width = 7)

ggsave(paste0(Sys.getenv("FIG_DIR"),
               "Manu_Files/",
                                  today,
              "Supp_Fig4_PredictedObserved_compartmentModels.pdf"),
       height = 5, width = 7)
  
```


### Figures 5 and Supplemental Figures 4 & 5: Model performance vs Data Variability

Here we examine the performance of "best fit" models with relation to data variability.
Here, because we are trying to specifically compare
data variability with model performance, we look at data with replicated timepoint observations, which are largely data with individual animal data.

```{r fig5-modelPerform-v-dataVar, eval=FALSE}
my_tf$indiv_data_test_fold_errors %>%
  select(model, starts_with("percent_")) %>%
  glimpse()

pl_5A <- my_tf$indiv_data_fold_errors %>%
  # For Plotting
  ggplot(aes(
    y = Fold_Error,
    x = foldConc
  )) +
  geom_bin2d(bins = 40, color = NA) +
  geom_hline(yintercept = c(0.5, 2), linetype = "dashed") +
  geom_vline(xintercept = c(0.5, 2), linetype = "dashed") +
  #facet_grid(cols = vars(model)) +
  scale_x_log10(labels = scales::label_math(format = log10),
                limits = c(0.001, 20)) +
  scale_y_log10(labels = scales::label_math(format = log10),
                limits = c(0.0001, 10000)) +
  annotation_logticks(sides = "bl") +
  scale_fill_viridis_c(option = "cividis",
                       limits = c(1, 100),
                       oob = scales::oob_squish) +
  labs(y = "Model Error",
       x = "Data Variability",
       fill = "Count") +
  theme(aspect.ratio = 1,
        panel.border = element_rect(color = "black", fill = NA, size = 1.5),
        panel.background = element_blank(),
        panel.grid.major = element_line(color = "grey90", linewidth = 0.5),
        strip.background = element_rect(fill = "white"),
        strip.text = element_text(face = "bold"),
        axis.ticks = element_blank(),
        axis.line = element_blank(),
        axis.text = element_text(size = 14),
        axis.title = element_text(size = 14)) 

pl_5A
ggsave(paste0(Sys.getenv("FIG_DIR"),
              today,
              "ModelPerformance_vDataVariability.png"),
       height = 5,
       width = 7,
       device = "png",
       dpi = 300,
       units = "in")  
```

Create table.

```{r}
  
my_table <- my_tf$indiv_data_test_fold_errors %>%
  ungroup() %>%
  filter(model %in% "All") %>%
  select(starts_with("percent_")) %>% t() %>%
  round(digits = 2) %>%
  as.data.frame() %>%
  rownames_to_column(var = "percentages") %>%
  mutate(percentages = case_when(
    percentages == "percent_both_within" ~ "Both within a factor of 2",
    percentages == "percent_both_outside" ~ "Both outside a factor of 2",
    percentages == "percent_model_outside" ~ "Model too variable",
    percentages == "percent_data_outside" ~ "Data too variable"
  ))
  


# names(my_table) <- c(" ","1-compartment (%)", "2-compartment (%)", "Overall (%)")

names(my_table) <- c(" ", "Overall (%)")

library(flextable)
library(officer)

flextable(my_table) %>%
  border_inner() %>%
  fontsize(part = "all", size = 11) %>%
  bold(part = "all", j = 2) %>%
  autofit()

table_plot <- gen_grob(flextable(my_table) %>%
                         border_inner() %>%
                         fontsize(part = "all", size = 10) %>%
                         bold(part = "all", j = 2) %>%
                         autofit(),
                       autowidths = TRUE,
                       fit = "width")


dual_plot <- plot_grid(pl_5A,
                       table_plot,
                       ncol = 1,
                       align = "hv",
          rel_heights = c(1, 0.5),
          rel_widths = c(1, 0.5)
          )

dual_plot

ggsave(paste0(Sys.getenv("FIG_DIR"),
              today,
              "ModelPerformance_vDataVariability_wTable.png"),
       plot = dual_plot,
       height = 4.5,
       width = 6,
       device = "png",
       bg = "white",
       dpi = 300,
       units = "in")  
```

### Figure 5Alt

```{r fig5Alt, eval=FALSE}
# Ultimately this will be removed from manuscript
my_tf$summarized_data_model_error %>%
  select(model, starts_with("percent_"))
```


### Figure 6: Multiple goodness-of-fit metrics validate model performance
Here we analyze and validate model performance per data group using R-squared,
RMSE, and fraction of predictions that are within 2-fold for each Chemical,
Species, Route, Media, and Dose groupings.

```{r fig6-goodness-of-fit, eval=FALSE}
combined_gof_df <- my_tf$model_error_all %>%
  group_by(Chemical, Species, model, method) %>%
  summarize(within_2fold = sum(between(Fold_Error, 0.5, 2))/n()) %>%
  left_join(r2_df) %>%
  left_join(myAIC) %>%
  left_join(myRMSLE) %>%
  semi_join(winmodel)
  

mypl <- ggplot(data = combined_gof_df,
               aes(
                 x = within_2fold,
                 y = Rsq,
                 color = model
               )) +
  geom_point() +
  geom_abline(slope = 1, color = "black", linetype = "longdash") +
  scale_color_manual(values = c("#0398FC", "#D68E09", "black")) +
    coord_cartesian(xlim = c(0,1), ylim = c(0,1)) +
  labs(x = "Fraction of predictions within 2-fold",
       y = "R-squared value") +
  theme(aspect.ratio = 1,
        panel.border = element_rect(color = "black", fill = NA, size = 1),
        panel.background = element_blank(),
        panel.grid.major = element_line(color = "grey90", linewidth = 0.5),
        axis.ticks = element_blank(),
        axis.line = element_blank(),
        legend.position = "none",
        legend.title = element_blank(),
        legend.key = element_blank()
  )
  
panelA_plot <- ggExtra::ggMarginal(mypl, groupFill = TRUE,
                    type = "histogram",
                    xparams = list(binwidth = 0.1),
                    yparams = list(binwidth = 0.1))
panelA_plot
ggsave(filename = paste0(Sys.getenv("FIG_DIR"),
                         today,
                         "R2_within2fold_comparison.png"),
       plot = ggExtra::ggMarginal(mypl, groupFill = TRUE,
                    type = "histogram",
                    xparams = list(binwidth = 0.05),
                    yparams = list(binwidth = 0.05)),
       height = 5,
       width = 5,
       units = "in")

panelB_plot <- ggplot(data = myRMSE,
               aes(
                 x = RMSE,
                 fill = model
               )) + 
  scale_x_log10() +
  annotation_logticks(sides = "b") +
  geom_histogram(bins = 50,
                 position = position_stack(),
                 color = NA) +
  labs(y = "Count") +
  #scale_color_manual(values = c("#0398FC", "#D68E09", "grey10")) +
  scale_fill_manual(values = c("#0398FC", "#D68E09", "grey10")) +
  # facet_grid(rows = vars(model),
  #            cols = vars(Route)) +
  theme(text = element_text(size = 10),
        aspect.ratio = 0.6,
    panel.border = element_rect(color = "black", fill = NA, size = 1),
        panel.background = element_blank(),
        panel.grid.major = element_line(color = "grey90", linewidth = 0.5),
        axis.ticks = element_blank(),
        axis.line = element_blank(),
        strip.background = element_blank(),
    panel.spacing.y = unit(0.125, units = "in"),
        legend.position = "bottom",
        legend.title = element_blank())
panelB_plot

ggsave(filename = paste0(Sys.getenv("FIG_DIR"),
                         today,
                         "RMSEs_winningmodel_RouteFacet.png"),
       height = 4,
       width = 6,
       units = "in")

legend <- get_legend(panelB_plot)

plot_grid(panelA_plot,
                   panelB_plot,
                   ncol = 2,
                   labels = c("A", "B"),
                   axis = "tb", align = "hv", rel_widths = c(1,1))
ggsave(filename = paste0(Sys.getenv("FIG_DIR"),
                         today,
                         "CombinedPlot_Rsquared_RMSE.png"),
       height = 4,
       width = 6.5,
       bg = "white",
       units = "in")
```


### Supp. Fig. 6 Examples fits for chemicals with R-squared and within 2-fold

```{r goodness-of-fit_exampleFits, eval = FALSE}
pl <- plot(my_pk,
           method = "bobyqa",
           best_fit = TRUE,
           use_scale_conc = list(dose_norm = TRUE,
                                 log10_trans = FALSE),
           drop_nonDetect = FALSE)

cvt %>% filter(curation_set_tag == "CVT_Showa") %>%
  pull(analyte_dtxsid) -> Showa_chems

combined_gof_df %>% filter(!(Chemical %in% Showa_chems)) %>% View()

ex_fits <- pl %>%
  filter(Chemical %in% c("DTXSID2020139",
                         "DTXSID4023917",
                         "DTXSID3061635",
                         "DTXSID1034187"),
         Species %in% "rat") %>%
  pull(final_plot)


cowplot::plot_grid(plotlist = list(ex_fits[[2]] +
                                     scale_color_manual(values = c("#a6bddb",
                                                                   "#74a9cf",
                                                                   "#41bbc4",
                                                                   "#2b8cbe",
                                                                   "#045a8d")) +
                                     theme(legend.position = "none") +
                                     xlim(0,30),
                                   ex_fits[[3]] +
                                     scale_color_manual(values = c("black",
                                                                   "grey40")) +
                                     theme(legend.position = "none"),
                                   ex_fits[[1]] +
                                     scale_color_manual(values = c("magenta3")) +
                                     theme(legend.position = "none"),
                                   ex_fits[[4]] +
                                     scale_color_manual(values = c("#006837")) +
                                     theme(legend.position = "none")),
                   scale = 0.85)

ggsave(filename = paste0(Sys.getenv("FIG_DIR"),
                         today,
                         "exampleFits_Rsq_within2fold.png"),
       height = 12,
       width = 12)

```

Also, save plots of the four chemicals that were best fit by the null model.

```{r}
pl <- plot(my_pk,
method = "bobyqa",
best_fit = FALSE,
use_scale_conc = list(dose_norm = TRUE,
log10_trans = FALSE),
drop_nonDetect = FALSE)

flat_fits <- pl %>% filter((Chemical %in% "DTXSID1021116" &
                             Species %in% "rat") |
                            ( Chemical %in% "DTXSID4020533" &
                             Species %in% "mouse") |
                              (Chemical %in% "DTXSID201029738" &
                             Species %in% "rat") |
                              (Chemical %in% "DTXSID2021315" &
                                 Species %in% "rat")) %>%
                              pull(final_plot)

cowplot::plot_grid(plotlist = flat_fits)

ggsave(filename = paste0(Sys.getenv("FIG_DIR"),
                         today,
                         "flat_winning_fits.pdf"),
       height = 12,
       width = 12)

ggsave(filename = paste0(Sys.getenv("FIG_DIR"),
                         today,
                         "flat_winning_fits.png"),
       height = 12,
       width = 12,
       dpi = 300)
```


### Figure 7: Comparing derived TK stats with human TK stats from Lombardo et al.

This meta-analysis compares the TK stats from model fits with other published studies.


```{r Lombardo_Comparison, eval=FALSE}
cvt_DTXSIDs <- unique(my_pk$data$Chemical)
# First things first, let's load the data from Lombardo et al.
lombardo <- readxl::read_xlsx(
  paste0(Sys.getenv("FIG_DIR"),
         "Lombardo2018-Supplemental_82966_revised_corrected.xlsx"),
  skip = 8)


l_batch_search <- readxl::read_xlsx(
  paste0(Sys.getenv("FIG_DIR"),
         "LombardoBatchSearch_Name.xlsx"),
  sheet = "Main Data"
)

  
l_batch_search <- l_batch_search[c("INPUT", "CASRN","DTXSID")] %>%
  distinct() %>%
  right_join(lombardo[c("Name", "CAS #")], by = c("CASRN" = "CAS #", "INPUT" = "Name"))



l_noNamesCASRN <- readxl::read_xlsx(
  paste0(Sys.getenv("FIG_DIR"),
         "LombardoBatchSearch_CASRNnoName.xlsx"),
  sheet = "Main Data"
) %>%
  dplyr::select(CASRN = INPUT, DTXSID)

l_curatedDTX <- read_tsv(paste0(Sys.getenv("FIG_DIR"),
                         "CuratedIDs_lombardo.txt")) %>%
  rename(INPUT = Name)


l_batch_search <- l_batch_search %>%
  left_join(l_noNamesCASRN, by = "CASRN") %>%
  mutate(DTXSID = coalesce(DTXSID.x, DTXSID.y)) %>%
  dplyr::select(-DTXSID.x, -DTXSID.y)
# Now all but two of the IDs are unidentified

lombardo <- lombardo %>%
  right_join(l_batch_search, by = c("Name" = "INPUT"))


####
lombard_abbr <- lombardo %>% dplyr::select(DTXSID,
                                           hVss = `human VDss (L/kg)`,
                                           hCltot = `human CL (mL/min/kg)`,
                                           halflife = `terminal  t1/2 (h)` ) %>%
  filter(DTXSID %in% cvt_DTXSIDs) %>%
  left_join(chem_name_translate, by = c("DTXSID" = "Chemical"))

# 15 chemicals in common with values for both
lombardo_comparison <- my_tkstats %>%
  dplyr::select(DTXSID = Chemical, Species,
                model, Vss.tkstats, CLtot.tkstats) %>%
  dplyr::filter(model != "model_flat") %>%
  distinct() %>%
  inner_join(lombard_abbr, by = "DTXSID") %>%
  # filter(!is.na(Vss.tkstats)) %>%
  arrange(halflife)

comparable_ids <- lombardo_comparison %>% pull(DTXSID)

lombard_abbr <- lombard_abbr %>%
  mutate(Species = "human", model = "Lombardo et al.") %>%
  rename(Vss = hVss, CLtot = hCltot) %>%
  mutate(CLtot = CLtot*60/1000) %>% # Lombardo reports this as mL/min/kg, need L/h/kg
  filter(DTXSID %in% comparable_ids) %>%
  mutate(Chemical_Name = reorder(Chemical_Name, halflife))

lombardo_comparison <- my_tkstats %>%
  dplyr::select(DTXSID = Chemical, Species,
                model, Vss.tkstats, CLtot.tkstats, halflife.tkstats) %>%
  filter(DTXSID %in% comparable_ids) %>%
  left_join(chem_name_translate, by = join_by(DTXSID == Chemical)) %>%
  distinct() %>%
  rename(Vss = Vss.tkstats, CLtot = CLtot.tkstats, halflife = halflife.tkstats) %>%
  bind_rows(lombard_abbr) %>%
  mutate(model = ifelse(str_detect(model, "^model"), "invivoPKfit", model),
         Chemical_Name = factor(Chemical_Name,
                                levels = levels(lombard_abbr$Chemical_Name)))

lombardo_comparison %>%
  pivot_longer(cols = c("Vss", "CLtot", "halflife")) %>%
  mutate(name = factor(name, levels = c("halflife", "Vss", "CLtot"))) %>%
  ggplot(mapping = aes(
    x = value,
    y = Chemical_Name
  )) +
  geom_point(aes(color = model,
                 shape = Species),
             position = position_dodge(0.7),
             size = 5/.pt, stroke = 2.5/.pt) +
  facet_grid(cols = vars(name),
             scales = "free_x") +
  scale_x_log10( labels = scales::label_math(format = log10)) +
  scale_shape_manual(values = c(21, 22, 24),
                     breaks = c("human", "dog", "rat")) +
  scale_color_manual(values = c("black", "#1064c9")) +
  guides(color = guide_legend(override.aes = list(shape = 21),
                              nrow = 2,
                              title.position = "top",
                              title.hjust = 0.5),
         shape = guide_legend(nrow = 1,
                              title.position = "top",
                              title.hjust = 0.5)) +
  theme(panel.border = element_rect(color = "black", fill = NA, linewidth = 1.5),
        panel.background = element_blank(),
        panel.grid.major = element_line(color = "grey90", linewidth = 0.5),
        strip.background = element_rect(fill = "white"),
        strip.text = element_text(face = "bold", size = 12),
        text = element_text(size = 10),
        axis.ticks = element_blank(),
        axis.line = element_blank(),
        axis.text = element_text(face = "bold", size = 6),
        axis.title.y = element_blank(),
        axis.title.x = element_blank(),
        legend.position = "bottom",
        legend.key = element_blank(),
        legend.title = element_text(face = "bold"),
        legend.text = element_text())

ggsave(filename = paste0(Sys.getenv("FIG_DIR"),
                         today,
                         "lombardoComparison_named.png"),
       height = 7,
       width = 6.5,
       device = "png", dpi = 300)

```


### Supp. Fig. 7: Fgutabs comparison with literature values compiled by Musther et al. (2014)

```{r otherMeta-analysis, eval=FALSE}

# Histograms
lombardo_hist <- data.frame(Chemical = c(lombardo$DTXSID,
                              my_tkstats$Chemical),
                            Vss = c(lombardo$`human VDss (L/kg)`,
                              my_tkstats$Vss.tkstats),
                            halflife = c(lombardo$`terminal  t1/2 (h)`,
                              my_tkstats$halflife.tkstats),
                            Source = c(rep_len("lombardo",
                                    length.out = nrow(lombardo)),
                              rep_len("invivoPKfit",
                                      length.out = nrow(my_tkstats))))


sfig4A <- lombardo_hist %>% 
  ggplot(aes(x = log2(Vss), color = Source,
             group = Source)) +
  geom_freqpoly(aes(y = after_stat(ndensity)),
                linewidth = 2/.pt,
                bins = 20) +
  labs(y = "Scaled Frequency",
       x = "Vss") +
  scale_x_continuous(labels = scales::label_math(expr = 2^.x)) +
  scale_color_manual(values = c("black", "#1064c9")) +
  guides(color = guide_legend(nrow = 2, linewidth = 1)) +
  theme(panel.border = element_rect(color = "black", fill = NA, linewidth = 1.5),
        panel.background = element_blank(),
        panel.grid.major = element_line(color = "grey90", linewidth = 0.5),
        strip.background = element_rect(fill = "white"),
        strip.text = element_text(face = "bold", size = 12),
        text = element_text(size = 10),
        axis.ticks = element_blank(),
        axis.line = element_blank(),
        axis.text = element_text(face = "bold"),
        legend.position = "bottom",
        legend.key = element_blank(),
        legend.title = element_text(face = "bold"),
        legend.text = element_text())

sfig4A
```

Compare with literature values of Fgutabs from the supplemental material of Musther et al. 2014.

Read in these literature values and reshape them to prepare for fitting.

```{r}
species_cols <- c(paste("Mouse",
       c("Dosing Formulation",
                    "Strain",
                    "Sex",
                    "F% Mean",
                    "F% Range"),
      sep = "."),

paste("Rat",
       c("Dosing Formulation",
                    "Strain",
                    "Sex",
                    "F% Mean",
         "WSD",
                    "F% Range"),
      sep = "."),

paste("Dog",
       c("Dosing Formulation",
                    "Strain",
                    "Sex",
                    "F% Mean",
         "WSD",
                    "F% Range"),
      sep = "."),

paste("Non-Human Primate",
       c("Dosing Formulation",
                    "Strain",
                    "Sex",
                    "F% Mean",
         "WSD",
                    "F% Range"),
      sep = "."),

paste("Human",
       c("Dosing Formulation",
                    "Sex",
                    "F% Mean",
         "WSD",
                    "F% Range"),
      sep = ".")
)



musther2014 <- readxl::read_excel(
  path = paste0(Sys.getenv("OD_DIR2"),
                "SupTableMusther2014.xlsx"),
  sheet = "Sheet1",
  skip = 1,
  col_names = c( "Compound",
                 "CAS",
                 "MW", "Ion Class",
               species_cols,
                "References.mouse",
                "References.rat",
                "References.dog",
                "References.NHP",
                "References.human"
                ),
  col_types = "text"
  ) 

#pivot longer
musther2014_long <- musther2014 %>%
  select(c(Compound,
           CAS,
         contains("F% Mean"))) %>%
  pivot_longer(cols = !c(Compound, CAS),
               names_to = c("Species", "stat"),
               names_sep = "\\.") %>%
  mutate(value = gsub(x=value,
                      pattern = "<",
                      replacement = ""),
         value_num = as.numeric(value))


```

Use `ctxR` to get DTXSIDs from CAS number.

```{r}
musther2014_dtxsid <- ctxR::chemical_equal_batch(word_list = unique(musther2014_long$CAS), API_key = Sys.getenv("ccd_api_key"))
```

```{r}

musther2014_long <- musther2014_long %>%
  left_join(musther2014_dtxsid %>% select(searchValue, dtxsid, preferredName),
            by = c("CAS" = "searchValue"))
```


Get Fgutabs estimates from the fitted `pk` object.

```{r}
fgutabs <- coef(my_pk, method = "bobyqa") %>%
  distinct() %>%
   semi_join(winmodel) %>% #keep only winning models
  rowwise() %>%
  mutate(Fgutabs = coefs_vector["Fgutabs"]) %>%
  filter(!is.na(Fgutabs))
```

Join with the literature estimates, keeping only cases with data in both tables

```{r}
fgutabs_pk_musther <- fgutabs %>% inner_join(musther2014_long,
                                             by = c("Chemical" = "dtxsid"))
```

How many chemicals with any data in Musther?

```{r}
fgutabs_pk_musther %>% pull(Chemical) %>% dplyr::n_distinct()
```

Only 7. What species were the in vivo CvT data from?

```{r}
fgutabs_pk_musther %>% distinct(Species.x)
```

All rat.

make a plot:

```{r}
#capitalize invivopkfit species to harmonize with Musther
fgutabs_pk_musther <- fgutabs_pk_musther %>%
  dplyr::mutate(Species.x =  stringr::str_to_sentence(Species.x))

ggplot(fgutabs_pk_musther) +
  geom_point(aes(y = preferredName,
                 x = Fgutabs,
                 shape = Species.x,
                 color = "invivopkfit"),
             size =4,
             stroke = 2) +
  geom_point(aes(y = preferredName,
                 x = value_num/100,
                 shape = Species.y,
                 color = "Musther et al. 2014"),
             size = 4,
             stroke = 2) +
  scale_shape_manual(values = c("Rat" = 21,
                                "Mouse" = 22,
                                "Dog" = 23,
                                "Non-Human Primate" = 24,
                                "Human" = 3),
                     breaks = c("Rat", "Mouse", "Dog", "Non-Human Primate", "Human")) +
  
  theme_bw() +
  theme(axis.title.y = element_blank(),
        legend.title = element_blank(),
        axis.title.x = element_text(size = 12),
        axis.text = element_text(size = 12),
        legend.text = element_text(size = 12)
        )

ggsave(filename = paste0(Sys.getenv("FIG_DIR"),
                         today,
                         "musther_Comparisons_SuppFigure4_named.pdf"),
       height = 5,
       width = 8)

ggsave(filename = paste0(Sys.getenv("FIG_DIR"),
                         today,
                         "musther_Comparisons_SuppFigure4_named.png"),
       height = 5,
       width = 8,
       device = "png", dpi = 300)
```

### Supp. Fig. 9: Parallelization decreases runtime of invivoPKfit

Here I do a bit of benchmarking for the parallel-ized version of do_fit

```{r do_fit-benchmarking, eval=FALSE}
# Randomize the order of chemical species
chem_spec <- cvt %>%
  dplyr::distinct(analyte_dtxsid, species) %>%
  dplyr::slice_sample(prop = 1)

test_group_size <- seq(25, 105, by = 10)
fit_options <- expand.grid(error_model = c("pooled",
                                           "hierarchical"),
                           dose_norm = FALSE,
                           log10_trans = TRUE,
                           time_scale = c(
                             TRUE,
                             FALSE),
                           stringsAsFactors = FALSE)

fit_options <- tidyr::expand_grid(fit_options, test_group_size)

fit_options <- fit_options %>% rowwise() %>%
  mutate(this_data = list({
    tmp <- chem_spec %>% slice_head(n = test_group_size) %>%
      left_join(cvt, by = join_by(analyte_dtxsid, species)) %>% 
      pk() +
        scale_time(new_units = ifelse(!time_scale, 
                                      "identity",
                                      "auto")) +
        scale_conc(dose_norm = dose_norm, log10_trans = log10_trans) +
        settings_preprocess(suppress.messages = TRUE)
    do_prefit(tmp)
  }
  ),
  data_size = chem_spec %>% slice_head(n = test_group_size) %>%
    left_join(cvt, by = join_by(analyte_dtxsid, species)) %>%
    NROW())

# Organization of the benchmarking
# For each fit_option, return the four values of system.time() that we want
df_out <- fit_options %>%
  rowwise() %>%
  mutate(tim_1core = system.time(do_fit(this_data))[["elapsed"]],
         tim_4core = system.time(do_fit(this_data, n_cores = 4))[["elapsed"]],
         tim_7core = system.time(do_fit(this_data, n_cores = 7))[["elapsed"]],
         tim_12core = system.time(do_fit(this_data, n_cores = 12))[["elapsed"]]
         )

df_out <- df_out %>% select(-this_data)
gc()

full_long <- df_out %>%
  pivot_longer(cols = c(tim_1core:tim_12core),
                        names_to = "N_cores",
                        values_to = "Time_s") %>%
  group_by(N_cores, test_group_size, data_size) %>%
  summarize(mean_time = mean(Time_s, na.rm = TRUE)/60,
            max_time = max(Time_s, na.rm = TRUE)/60,
            min_time = min(Time_s, na.rm = TRUE)/60
            ) %>%
  mutate(N_cores = as.numeric(str_extract(N_cores, "[:digit:]+")))

df_out %>% clipr::write_clip()
ggplot(full_long,
       aes(x = test_group_size,
           y = mean_time,
           color = as.factor(N_cores))) +
  geom_point() +
  geom_linerange(aes(ymin = min_time,
                ymax = max_time)) +
  geom_line(aes(group = N_cores)) +
  labs(x = "Number of Data Groups",
       y = "Runtime (minutes)",
       title = "Number of Processing Cores",
       subtitle = "(with min/max runtime range)") +
  facet_grid(cols = vars(N_cores)) +
  scale_color_manual(values = c("black", "#40c679", "#31a354", "#006837")) +
  coord_fixed(ratio = 8) +
  theme(panel.border = element_rect(color = "black", fill = NA, size = 1.5),
        panel.background = element_blank(),
        panel.grid.major = element_line(color = "grey90", linewidth = 0.5),
        legend.position = "none",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5),
        axis.ticks = element_blank(),
        axis.line = element_blank(),
        strip.background = element_blank())




ggsave(paste0(Sys.getenv("FIG_DIR"),
              "Manu_Files/",
              today,
              "Supp_Fig8_Parallelization_Benchmarking.png"),
       width = 5,
       height = 2.5,
       units = "in")

```

```{r information}
sessionInfo()
```
