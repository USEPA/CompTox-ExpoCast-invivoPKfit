I want a grammar like ggplot2 or dplyr, in fact something compatible with dplyr, like

fit_list <- cvt %>%
dplyr::group_by(DTXSID, Species) %>%
pk() %>%
setup_fit(error_group = ~ DTXSID + Species + Reference + Media,
            model_info = list(model = "flat",
                                      model.type = "analytic"),
                    data_trans = list(dose_norm = TRUE,
                                      log10_trans = FALSE,
                                      rescale_time = TRUE),
                    optim_control = list(
                      method = "bobyqa",
                      itnmax = 1e6,
                      control = list(kkt = FALSE)
                    ),
                    get_lower_args = list(Vdist_from_species = FALSE),
                    get_upper_args = list(Fgutabs_Vdist_from_species = FALSE,
                                          sigma_from_data = TRUE),
                    get_starts_args = list(start_from_httk = "all",
                                           start_from_data = "all")) %>%
do_fit()


Maybe even something that would take the original CvTdb names and use something like an "aes" or "mapping" argument to map to harmonized names, like

fit_list <- cvt %>%
filter(chemicals_dosed.dsstox_substance_id == chemicals_analyzed.dsstox_substance_id &
studies.administration_route_normalized %in% c("po", "iv")) %>%
dplyr::group_by(chemicals_dosed.dsstox_substance_id,
subjects.species) %>%
pk(mapping = list(
  "Compound_Dosed" = "studies.test_substance_name_original",
  "DTXSID_Dosed" = "chemicals_dosed.dsstox_substance_id",
  "CAS_Dosed" = "chemicals_dosed.dsstox_casrn",
  "Compound_Analyzed" = "series.analyte_name_original",
  "DTXSID_Analyzed" = "chemicals_analyzed.dsstox_substance_id",
  "CAS_Analyzed" = "chemicals_analyzed.dsstox_casrn",
  "Reference" = "documents_reference.id",
  "Extraction" = "documents_extraction.id",
  "Species" = "subjects.species",
  "Weight" ="subjects.weight_kg",
  "Weight.Units" = NULL,
  "Dose" = "studies.dose_level_normalized_corrected", #note that dose levels were corrected in pulling_oral_iv_data_cvtdb.Rmd
  "Dose.Units" = NULL,
  "Time" = "conc_time_values.time_hr",
  "Time.Units" = NULL,
  "Media" = "series.conc_medium_normalized",
  "Value" = "conc_time_values.conc", #already normalized to mg/L units in CvTdb
  "Value.Units" = NULL,
  "Route" = "studies.administration_route_normalized",
  "LOQ" = "series.loq_normalized", #note that LOQs were normalized to mg/L units in pulling_oral_iv_data_cvtdb.Rmd
  "Subject" = "subjects.id",
  "N_Subjects" = "series.n_subjects_in_series",
  "Value_SD" = "conc_time_values.conc_sd_normalized", #note that SDs were normalized to mg/L units in pulling_oral_iv_data_cvtdb.Rmd
  "Study_ID" = "studies.id",
  "Series_ID" = "series.id"
  ),
  impute_loq = TRUE,
  impute_sd = TRUE
  ) %>%
setup_fit(error_group = ~ DTXSID + Species + Reference + Media, #formula to define groupings for ""study""
            model_info = list(model = "flat",
                                      model.type = "analytic"),
                    data_trans = list(dose_norm = TRUE,
                                      log10_trans = FALSE,
                                      rescale_time = TRUE),
                    optim_control = list(
                      method = "bobyqa",
                      itnmax = 1e6,
                      control = list(kkt = FALSE)
                    ),
                    get_lower_args = list(Vdist_from_species = FALSE),
                    get_upper_args = list(Fgutabs_Vdist_from_species = FALSE,
                                          sigma_from_data = TRUE),
                    get_starts_args = list(start_from_httk = "all",
                                           start_from_data = "all")) %>%
do_fit()

Then you would end up with a single list column of fitted pk objects by whatever was specified in dplyr::group_by().

You could then apply some methods like one called summarize_fit, which would produce a data.frame with all the info formatted nicely

fit_list %>% rowwise(summarize_fit())

Actually, we would like to be able to have multiple fits for each dataset so that we could compare models. Essentially this should work like having multiple layers in ggplot2. So maybe something like, instead of + geom_point() + geom_smooth(), we could do something like + model_flat() + model_1comp()?

Under the hood it would give us a named list of "layers" or "models", like $models$flat and $models$1comp. If you only added one model, you'd only have one list item.

Then we could do something akin to scale_... arguments in ggplot2, to define data transformations. Something like normalize_conc_dose() or normalize_conc_identity(), or scale_conc_log10() or scale_conc_identity(), or scale_time_identity() or scale_time_auto() (to automatically pick the "best" time rescaling) or scale_time_days() (to forcibly scale to days, or corresponding functions for other time units)

Maybe simpler, more like scale_conc(normalize = "identity", trans = "identity") or scale_conc(normalize = "dose", trans = "log10"), and scale_time(trans = "auto") or scale_time(trans = "identity")

Then when you did something like summarize_fit(), it would loop over the named list of models and produce a summary data.frame for each one.

Then you could also do like compare_models() to get the model comparison info (AIC, BIC, log-likelihood per model)

Or summarize_winning_model(), to get the post-processed summary data.frame for the winning model

Or plot() -- which could take options to plot data only, plot all models, or plot only the winning model


Fitting options could be equivalent to ggplot2::theme()? Or perhaps they go like e.g. options to stat_smooth() -- but it would be annoying to have to re-specify them all for every single model we want to add -- there needs to be some way to specify them globally.
