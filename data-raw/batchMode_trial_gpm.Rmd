---
title: "PK object batch mode trial"
author: "Gilberto Padilla Mercado"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)

library(tidyverse, quietly = TRUE)
devtools::load_all() # Loads the invivopkfit package in feature/pkS3obj_facet branch
tidyverse_conflicts()
```

## Working with one DTXSID + Species combination

The first step is understanding how to work with a single DTXSID + Species combination.
Once we know how to do this, it will be easier to apply it to (potentially)
a list of these objects in a vectorized fashion.
Here I subset the `cvt` object and use that as my working data.

```{r data_loading}
# There are 103 unique chemicals in this object
cvt %>% pull(chemicals_analyzed.dsstox_substance_id) %>%
  unique() %>%
  length()

my_predata <- subset(cvt,
                     chemicals_analyzed.dsstox_substance_id %in% "DTXSID0020442")



```

Next, I want to follow the steps required for the particular analysis I would like.
In this instance, I set the optimizer to "L-BFGS-B" and dose-normalize the output.
I do not scale the time or log-transform the concentration values.
Since I would like to do a "Pooled" analysis,
I set the `error_group = vars(Chemical, Species)`.

```{r single_fit}
my_pk <- pk(data = my_predata) +
  facet_data(vars(Chemical, Species)) +
  settings_preprocess(keep_data_original = TRUE) +
  settings_optimx(method = c("L-BFGS-B", "bobyqa")) +
  scale_conc(dose_norm = TRUE) +
  # scale_time() +
  # stat_model() + 
  stat_error_model(error_group = vars(Chemical, Species, Reference)) 

my_pk <- do_preprocess(my_pk)

my_pk <- do_data_info(my_pk) 
# summarizes error (Returning more or less than 1 row per summarize)

my_pk <- do_prefit(my_pk) 

my_pk <- do_fit(my_pk)



```

Batch mode works, now I need to write a function that recapitulates `coef()` method

```{r coef_function_remake}
# A list of each fit model with the estimated parameters for that model
pk_results <- coef(my_pk)

# New possible coef function!!
my_coef <- function(obj,
                    data_group = NULL,
                    ...) {
  # Check fit status
  check <- check_required_status(obj = obj,
                                 required_status = status_fit)
  
  if (check %in% FALSE) stop(attr(check, "msg")) # Stop if not fitted
  
  const_pars <- subset(obj$prefit$par_DF,
                       optimize_param %in% FALSE &
                         use_param %in% TRUE) %>% dplyr::select(model,
                                                                !!!obj$data_group,
                                                                param_name,
                                                                start) 
  const_pars <- const_pars %>%
    pivot_wider(names_from = param_name,
                values_from = start)
  
  possible_model_params <- sapply(obj$stat_model, `[[`, "params") %>%
    unlist() %>%
    unique()
  
  coefs <- obj$fit %>% unnest(cols = fit) %>%
    group_by(model, method, !!!obj$data_group) %>%
    dplyr::select(starts_with("sigma_"),
                  any_of(possible_model_params)) %>%
    unite(starts_with("sigma_"),
          col = "sigma",
          sep = "",
          na.rm = TRUE)
  
  coefs <- left_join(coefs, const_pars)
  
  coefs_tidy <- coefs %>%
  nest(coefs_tibble = any_of(possible_model_params)) %>%
  mutate(coefs_vector = map(coefs_tibble,
                      .f = \(x){
                        as.data.frame(x %>%
                                    dplyr::select(!where(is.na))) %>% 
                          unlist()
                      })) %>%
    unnest(coefs_tibble)
  return(coefs_tidy)
}

my_coefs <- my_coef(obj = my_pk)


```


```{r predict_method_remake}
my_predict <- function(obj,
                       newdata = NULL,
                       model = NULL,
                       method = NULL,
                       type = "conc",
                       exclude = TRUE,
                       use_scale_conc = FALSE,
                       ...){
  
  #ensure that the model has been fitted
  check <- check_required_status(obj = obj,
                                 required_status = status_fit)
  if(!(check %in% TRUE)){
    stop(attr(check, "msg"))
  }
  
  if(is.null(model)) model <- names(obj$stat_model)
  if(is.null(method)) method <- obj$settings_optimx$method
  
  method_ok <- check_method(obj = obj, method = method)
  model_ok <- check_model(obj = obj, model = model)
  
  coefs <- coef(obj = obj) %>%
    dplyr::filter(model %in% model,
                  method %in% method)
  
  if(is.null(newdata)) newdata <- obj$data
  
  newdata_ok <- check_newdata(newdata = newdata,
                              olddata = obj$data,
                              req_vars = c("Time",
                                           "Time.Units",
                                           "Dose",
                                           "Route",
                                           "Media"),
                              exclude = exclude)
  
  #scale time if needed
  if(!("Time_trans" %in% names(newdata))){
    newdata$Time_trans <- convert_time(x = newdata$Time,
                                       from = newdata$Time.Units,
                                       to = obj$scales$time$new_units)
  }
  
  #apply transformations if so specified
  conc_scale <- conc_scale_use(obj = obj,
                               use_scale_conc = use_scale_conc)
  
  req_vars <- c("Time",
                "Time.Units",
                "Dose",
                "Route",
                "Media",
                "Value",
                "Value.Units")
  
  trans_vars <- c("Time_trans",
                  "Time_trans.Units",
                  "Conc_trans",
                  "Conc_trans.Units")
  
  newdata <- newdata %>%
    dplyr::select(!!!obj$data_group,
                  all_of(req_vars),
                  any_of(trans_vars)) %>%
    group_by(!!!obj$data_group,
             Route, Media) %>%
    nest(.key = "observations")
  
  newdata <- left_join(coefs, newdata,
                       relationship = "many-to-many")
  # From here, trying to call map within mutate to add the prediction column by
  # calling the appropriate model function and feeding it the parameters in coefs_vector
  
  newdata <- newdata %>%
    dplyr::group_by(Route, Media,
                    .add = TRUE) %>%
    mutate(model_fun = case_when(
      type == "conc" ~obj$stat_model[[model]]$conc_fun,
      type == "auc"  ~obj$stat_model[[model]]$auc_fun,
      .default = obj$stat_model[[model]]$conc_fun)) %>%
    reframe(predictions = 
              map(observations,
                  .f = \(x) {
                    x %>%
                      group_by(Time_trans) %>% # revise!
                      mutate(Estimate = sapply(coefs_vector,
                                               FUN = model_fun,
                                               time = Time_trans,
                                               dose = ifelse(obj$scales$conc$dose_norm,
                                                             1, Dose),
                                               route = Route,
                                               medium = Media,
                                               simplify = TRUE,
                                               USE.NAMES = TRUE))
                              })) %>%
    unnest(predictions)
  
  if (type == "conc") newdata <- rename(newdata, Conc_est = "Estimate")
  if (type == "auc") newdata <- rename(newdata, AUC_est = "Estimate")
  
  
  return(newdata) 
}

my_pred <- my_predict(my_pk, type = "auc", use_scale_conc = TRUE)


my_pred %>%
  filter(model == "model_flat",
         Route == "iv",
         Species == "hamster",
         method == "L-BFGS-B") %>%
  View()

```


```{r after_method_update}
# Changed pk_methods coef() and predict() to those above
# Ran the following after making the pk object:
devtools::load_all()

my_coefs_update <- coef(my_pk, drop_sigma = TRUE)
my_pred_update <- predict(my_pk,
                          use_scale_conc = TRUE)


my_pred_update %>%
  filter(model == "model_2comp",
         Route == "oral",
         Species == "rat", # hamster has a Fgutabs of zero
         method == "L-BFGS-B") %>%
  View("predicted_update")

my_coefs_update %>%
  filter(model == "model_flat",
         Species == "rat",
         method == "L-BFGS-B") %>%
  View("coef_update")

# Seems to have worked!
```



```{r remaining_methods}
# rmse()
# get_tkstats()
# residuals()
# plot()


my_tkstats <- get_tkstats(my_pk)

plot_results <- plot(my_pk)


```



